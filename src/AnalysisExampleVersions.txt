//was the first attempt to just disqualify max E strip-didn't result in gaining back counts
// stripdifx=maxchx-stripimpx; //will be positive for strips greater than the imp strip
    //stripdify=maxchy-stripimpy; //will be positive for strips greater than the imp strip
    /* stripdifx=maxchf-stripimpx;
    //try just for 1-d and see what you come up with
    if(stripdifx>0){
      for(int x=1;x<stripimpx+1;x++){//only want the lower numbered strips excpet the implant pixel
	if(totaledep_stripx[x]>20) hEventsSeparateFromElectron->Fill(totaledep_stripx[x]);
      }
    }else if(stripdifx>0){
      for(int x=stripimpx+1;x<17;x++){//only want the higher numbered strips excpet the implant pixel
	if(totaledep_stripx[x]>20) hEventsSeparateFromElectron->Fill(totaledep_stripx[x]);
      }
    }else{
      for(int x=1;x<17;x++){//if it's in the same pixel, want all except that pixel
	if(totaledep_stripx[x]>20&&x!=maxchf) hEventsSeparateFromElectron->Fill(totaledep_stripx[x]);
      }
    }
    if(stripdifx==0 && stripdify==0){//will assume if it's in the same strip that any other strip is ok for now
      for(int x=1;x<17;x++){
	for(int y=1;y<stripimpy+1;y++){
	  if((maxchy+1!=y)&&(maxchx+1!=x)&&(totaledepxy[x][y]>20)){//match exp lower thresh-maxch is in realstrips, y and x are not
	    hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);//plot of all channels except max energy channel
	  }
	}
      }
    }else if(stripdifx>0&&stripdify>0){
      for(int x=1;x<stripimpx+1;x++){//strip imp is in "real" strip numbers
	for(int y=1;y<stripimpy+1;y++){
	  if(totaledepxy[x][y]>20)  hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	  }
	}
    }else if(stripdifx>0&&stripdify<0){
      for(int x=1;x<stripimpx+1;x++){//strip imp is in "real" strip numbers
	for(int y=stripimpy+1;y<17;y++){
	  if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	}
      }
    }else if(stripdifx<0&&stripdify>0){
      for(int x=stripimpx+1;x<17;x++){//strip imp is in "real" strip numbers
	for(int y=1;y<stripimpy+1;y++){
	  if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	}
      }
    }else if(stripdifx<0&&stripdify<0){
      for(int x=stripimpx+1;x<17;x++){//strip imp is in "real" strip numbers
	for(int y=stripimpy+1;y<17;y++){
	  if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	}
      }
    }else if(stripdifx==0&&stripdify!=0){
      for(int x=1;x<17;x++){//strip imp is in "real" strip numbers-only x strip we don't want is the implant strip
	if(x!=stripimpx+1){
	  if(stripdify>0){
	    for(int y=1;y<stripimpy+1;y++){//want all stips up to implant if y is higher than imp
	      if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	    }
	  }else{
	    for(int y=stripimpy+1;y<17;y++){//want the strips greater than implant if y is less than imp
	      if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	    }
	  }
	}
      }
    }else if(stripdifx!=0&&stripdify==0){
      for(int y=1;y<17;y++){//strip imp is in "real" strip numbers-only x strip we don't want is the implant strip
	if(y!=stripimpy+1){
	  if(stripdifx>0){
	    for(int x=1;x<stripimpx+1;x++){//want all stips up to implant if y is higher than imp
	      if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	    }
	  }else{
	      for(int x=stripimpx+1;x<17;x++){//want the strips greater than implant if y is less than imp
		if(totaledepxy[x][y]>20) hEventsSeparateFromElectron->Fill(totaledepxy[x][y]);
	      }
	    }
	}
      }
      }*/

#############################################################################################################################################
Copy of AlgorithmV1
     int maxesequal=0;
    //int maxesequal=5;//so that I can just compare the maxes and bypass the algorithm
    int secondequal=0;
    int thirdequal=0;
    if(countf==1&&countb==1){//start with mult one both way events-we know that the x and y must go together
      totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf];
      // cout<<maxb<<" front"<<maxf<<endl;
    }else /*(if(countf==countf)*/{//if they're not both equal to one-if there's only two/1 etc, it should just keep the higher maxes at 0
      if(maxf-maxb<20&&maxf-maxb>-20){
	totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf]; //if the maxes are equal to each other
	maxesequal=1;
      }
      //cout<<maxb<<" front"<<maxf<<endl;
      //second max
      //  if(countf>=2){
	for(int x=1;x<17;x++){
	  //int y=x-1;
	  // if(totaledep_stripx[x]>20){
	  // if(countf==1){
	  //  hMult1x->Fill(totaledep_stripx[x]);
	  // }else{
	  //  hMultmanyx->Fill(totaledep_stripx[x]);
	  // }
	  // }
	  //   if(countf==countb){
	  //finding second max
	  if((totaledep_stripx[x]>secondmaxf)&&(totaledep_stripx[x]<maxf)){
	    secondmaxf=totaledep_stripx[x];
	    secondmaxchf=x;
	  }
	  if((totaledep_stripy[x]>secondmaxb)&&(totaledep_stripy[x]<maxb)){
	    secondmaxb=totaledep_stripy[x];
	    secondmaxchb=x;
	  }
	  // }
	}
	//	cout<<secondmaxb<<" front"<<secondmaxf<<endl;
	if(maxesequal==1){//only equate second maxes if first maxes were also equal
	  if(secondmaxf-secondmaxb<20&&secondmaxf-secondmaxb>-20){
	    totaledepxy[secondmaxchf][secondmaxchb]=totaledep_stripx[secondmaxchf];
	    maxesequal=2;//first and second maxes are both equal
	  }
	  
	}else{
	  if(secondmaxf-secondmaxb<20&&secondmaxf-secondmaxb>-20){
	    totaledepxy[secondmaxchf][secondmaxchb]=totaledep_stripx[secondmaxchf];
	    secondequal=2;
	  }
	}
	//if(countf==1) cout<<maxf<<" "<<secondmaxf<<" "<<secondmaxb<<endl;//to check that it keeps one 0 and will still increment the other if need be
	//  }//end countf>2
      //third max
	//   if(countf>=3){
	for(int x=1;x<17;x++){
	  //  if(countf==countb){
	  if((totaledep_stripx[x]>thirdmaxf)&&(totaledep_stripx[x]<secondmaxf)){
	    thirdmaxf=totaledep_stripx[x];
	    thirdmaxchf=x;
	  }
	  if((totaledep_stripy[x]>thirdmaxb)&&(totaledep_stripy[x]<secondmaxb)){
	    thirdmaxb=totaledep_stripy[x];
	    thirdmaxchb=x;
	  }
	  //  }
	}
	if(maxesequal==2){//only equate third if all others were equal before
	  if(thirdmaxf-thirdmaxb<20&&thirdmaxf-thirdmaxb>-20){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=totaledep_stripx[thirdmaxchf];
	    maxesequal=3;
	  }
	}else{//so if first max was unequal
	  if(thirdmaxf-thirdmaxb<20&&thirdmaxf-thirdmaxb>-20){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=totaledep_stripx[thirdmaxchf];
	    if(secondequal==2){
	      secondequal=3;
	    }else{
	      thirdequal=3;
	    }
	  }
	}
	//  }//end countf>3
      //fourth max
    //  if(countf>=4){
	for(int x=1;x<17;x++){
	  // if(countf==countb){
	  if((totaledep_stripx[x]>fourthmaxf)&&(totaledep_stripx[x]<thirdmaxf)){
	    fourthmaxf=totaledep_stripx[x];
	    fourthmaxchf=x;
	  }
	  if((totaledep_stripy[x]>fourthmaxb)&&(totaledep_stripy[x]<thirdmaxb)){
	    fourthmaxb=totaledep_stripy[x];
	    fourthmaxchb=x;
	  }
      // }
	}
	if(maxesequal==3){//only equate fourth if all others were equal first
	  if(fourthmaxf-fourthmaxb<20&&fourthmaxf-fourthmaxb>-20){
	    totaledepxy[fourthmaxchf][fourthmaxchb]=totaledep_stripx[fourthmaxchf];
	    maxesequal=4;
	  }
	}
	//  }//end countf>4
    }//end else if countf and countb are not 1
    // cout<<maxesequal<<endl;
    if(maxesequal==0){//none of the maxes match
      /*if(countf==1){
	if((maxf-(maxb+secondmaxb+thirdmaxb+fourthmaxb)<20)&&(maxf-(maxb+secondmaxb+thirdmaxb+fourthmaxb)>-20)){//this event is one strip with three strips on the other side
	  totaledepxy[maxchf][maxchb]=maxb;
	  totaledepxy[maxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[maxchf][thirdmaxchb]=thirdmaxb;
	  totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	}
      }else if(countb==1){//end countf==1
	if((maxb-(maxf+secondmaxf+thirdmaxf+fourthmaxf)<20)&&(maxb-(maxf+secondmaxf+thirdmaxf+fourthmaxf)>-20)){//this event is one strip with three strips on the other side
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[secondmaxchf][maxchb]=secondmaxf;
	  totaledepxy[thirdmaxchf][maxchb]=thirdmaxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	  }*/
      /* }else*/ if(((maxf-(secondmaxb+thirdmaxb+fourthmaxb))-(maxb-(secondmaxf+thirdmaxf+fourthmaxf))<20)&&((maxf-(secondmaxb+thirdmaxb+fourthmaxb))-(maxb-(secondmaxf+thirdmaxf+fourthmaxf))>-20)){//end countb==1
	totaledepxy[maxchf][maxchb]=maxb-(secondmaxf+thirdmaxf+fourthmaxf);
	totaledepxy[maxchf][secondmaxchb]=secondmaxb;
	totaledepxy[maxchf][thirdmaxchb]=thirdmaxb;
	totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	totaledepxy[secondmaxchf][maxchb]=secondmaxf;
	totaledepxy[thirdmaxchf][maxchb]=thirdmaxf;
	totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
      }else if(secondequal==2){//so the max channels don't equal, but the second maxes are
	if((maxf-(maxb+thirdmaxb+fourthmaxb)<20)&&(maxf-(maxb+thirdmaxb+fourthmaxb)>-20)){
	    totaledepxy[maxchf][maxchb]=maxb;
	    totaledepxy[maxchf][thirdmaxchb]=thirdmaxb;
	    totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	  }
	if((maxb-(maxf+thirdmaxf+fourthmaxf)<20)&&(maxb-(maxf+thirdmaxf+fourthmaxf)>-20)){
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[thirdmaxchf][maxchb]=thirdmaxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	}

      }else if(secondequal==3){//the max channels don't equal, but the third and second maxes do
	if((maxf-(fourthmaxb+maxb)<20)&&(maxf-(fourthmaxb+maxb)>-20)){
	  totaledepxy[maxchf][maxchb]=maxb;
	  totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	}
	if((maxb-(maxf+fourthmaxf)<20)&&(maxb-(maxf+fourthmaxf)>-20)){
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	}

      }else if(thirdequal==3){//the max and second don't equal, but the third does
	if((maxf-(maxb+secondmaxb+fourthmaxb)<20)&&(maxf-(maxb+secondmaxb+fourthmaxb)>-20)){
	    totaledepxy[maxchf][maxchb]=maxb;
	    totaledepxy[maxchf][secondmaxchb]=secondmaxb;
	    totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	  }
	if((maxb-(maxf+secondmaxf+fourthmaxf)<20)&&(maxb-(maxf+secondmaxf+fourthmaxf)>-20)){
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[secondmaxchf][maxchb]=secondmaxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	}
      }
      
    }else if(maxesequal==1){//so the maximum energy channels match, but the seccond doesn't
      // if(countf==2){
	if((secondmaxf-(secondmaxb+thirdmaxb+fourthmaxb)<20)&&(secondmaxf-(secondmaxb+thirdmaxb+fourthmaxb)>-20)){//all other events on back are on one line on the front
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;//basically do the same with the second max as I did with the max above
	  totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	}else if((secondmaxf-(thirdmaxb+fourthmaxb)<20)&&(secondmaxf-(thirdmaxb+fourthmaxb)>-20)){
	  totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;//basically do the same with the second max as I did with the max above
	  totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	  if((secondmaxb-thirdmaxf<20)&&(secondmaxb-thirdmaxf>-20)){//if the second max on the back does not corropsond to the second max on the front, see if it goes with one of the others
	    totaledepxy[thirdmaxchf][secondmaxchb]=secondmaxb;
	    
	  }else if((secondmaxb-fourthmaxf<20)&&(secondmaxb-fourthmaxf>-20)){
	    totaledepxy[fourthmaxchf][secondmaxchb]=secondmaxb;
	  }else if(((secondmaxb-(thirdmaxf+fourthmaxf)<20)&&(secondmaxb-(thirdmaxf+fourthmaxf)>-20))){//doesn't seem to be many cases of this
	    totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;
	    totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	  }//end checking if the other side's 2nd max is equal to some smaller max on the front
	  //case where the second max is separated from the 
	}else if((secondmaxb-(secondmaxf+thirdmaxf+fourthmaxf)<20)&&(secondmaxb-(secondmaxf+thirdmaxf+fourthmaxb)>-20)){//all other events on front are on one line with the back
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxf;
	  totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;//basically do the same with the second max as I did with the max above
	  totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	}else if((secondmaxb-(thirdmaxf+fourthmaxf)<20)&&(secondmaxb-(thirdmaxf+fourthmaxb)>-20)){//all other events on front are on one line with the back
	  totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;//basically do the same with the second max as I did with the max above
	  totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	  if((secondmaxf-thirdmaxb<20)&&(secondmaxf-thirdmaxb>-20)){//if the second max on the back does not corropsond to the second max on the front, see if it goes with one of the others
	    totaledepxy[secondmaxchf][thirdmaxchb]=secondmaxf;
	    
	  }else if((secondmaxf-fourthmaxb<20)&&(secondmaxf-fourthmaxb>-20)){
	    totaledepxy[secondmaxchf][fourthmaxchb]=secondmaxf;
	  }else if(((secondmaxf-(thirdmaxb+fourthmaxb)<20)&&(secondmaxf-(thirdmaxb+fourthmaxb)>-20))){//doesn't seem to be many cases of this
	    totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;
	    totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	  }//end checking if the other side's 2nd max is equal to some smaller max on the back
	  //end for case where other side's 2nd max is the same as a lesser max on the back
	}else if((secondmaxf-(secondmaxb+thirdmaxb)<20)&&(secondmaxf-(secondmaxb+thirdmaxb)>-20)){//there's a fourth max, but it's a separate event
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;
	  if((fourthmaxb-thirdmaxf<20)&&(fourthmaxb-thirdmaxf>-20)){
	    totaledepxy[thirdmaxchf][fourthmaxchb]=thirdmaxf;
	  }
	}else if((secondmaxb-(secondmaxf+thirdmaxf)<20)&&(secondmaxb-(secondmaxf+thirdmaxf)>-20)){//all other events on front are on one line with the back
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxf;
	  totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;
	  if((fourthmaxf-thirdmaxb<20)&&(fourthmaxf-thirdmaxb>-20)){
	    totaledepxy[fourthmaxchf][thirdmaxchb]=thirdmaxb;
	  }
	}else if((secondmaxf-(secondmaxb+fourthmaxb)<20)&&(secondmaxf-(secondmaxb+fourthmaxb)>-20)){//there's a fourth max, but it's a separate event
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	  if((thirdmaxb-thirdmaxf<20)&&(thirdmaxb-thirdmaxf>-20)){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxf;
	  }
	}else if((secondmaxb-(secondmaxf+fourthmaxf)<20)&&(secondmaxb-(secondmaxf+fourthmaxf)>-20)){//all other events on front are on one line with the back
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxf;
	  totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	  if((thirdmaxf-thirdmaxb<20)&&(thirdmaxf-thirdmaxb>-20)){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxb;
	  }
	}
	
    }else if(maxesequal==2){//the first two highest match, but the third doesn't
      if((thirdmaxf-(thirdmaxb+fourthmaxb)<20)&&(thirdmaxf-(thirdmaxb+fourthmaxb)>-20)){
	totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxb;//basically do the same with the second max as I did with the max above
	totaledepxy[thirdmaxchf][fourthmaxchb]=fourthmaxb;
      }else if((thirdmaxb-(thirdmaxf+fourthmaxf)<20)&&(thirdmaxb-(thirdmaxf+fourthmaxf)>-20)){
	totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxf;//basically do the same with the second max as I did with the max above
	totaledepxy[fourthmaxchf][thirdmaxchb]=fourthmaxf;
	}else if(((thirdmaxf-fourthmaxb)-(thirdmaxb-fourthmaxf)<20)&&((thirdmaxf-fourthmaxb)-(thirdmaxb-fourthmaxf)>-20)){
	totaledepxy[thirdmaxchf][fourthmaxchb]=fourthmaxb;
	totaledepxy[fourthmaxchf][thirdmaxchb]=fourthmaxf;
	totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxb-fourthmaxf;
      }
    }//end comparing the energy maxes
end of algorithmV1
####################################################################################################################################
copy of V1.1
     int maxesequal=0;
    //int maxesequal=5;//so that I can just compare the maxes and bypass the algorithm
    int secondequal=0;
    int thirdequal=0;
    int testing=0;
    double percent=0.05;//making a percentage that I can easily change
    if((countf==1)&&(countb==1)){//start with mult one both way events-we know that the x and y must go together
      totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf];
      // cout<<maxb<<" front"<<maxf<<endl;
    }
    else{//if they're not both equal to one-if there's only two/1 etc, it should just keep the higher maxes at 0
      if((abs(maxf-maxb)/maxf)<percent){
	totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf]; //if the maxes are equal to each other
	maxesequal=1;
      }
      //cout<<maxb<<" front"<<maxf<<endl;
      //second max
      //  if(countf>=2){
	for(int x=1;x<17;x++){
	  //int y=x-1;
	  // if(totaledep_stripx[x]>20){
	  // if(countf==1){
	  //  hMult1x->Fill(totaledep_stripx[x]);
	  // }else{
	  //  hMultmanyx->Fill(totaledep_stripx[x]);
	  // }
	  // }
	  //   if(countf==countb){
	  //finding second max
	  if((totaledep_stripx[x]>secondmaxf)&&(totaledep_stripx[x]<maxf)){
	    secondmaxf=totaledep_stripx[x];
	    secondmaxchf=x;
	  }
	  if((totaledep_stripy[x]>secondmaxb)&&(totaledep_stripy[x]<maxb)){
	    secondmaxb=totaledep_stripy[x];
	    secondmaxchb=x;
	  }
	  // }
	}
	//	cout<<secondmaxb<<" front"<<secondmaxf<<endl;
	if(maxesequal==1){//only equate second maxes if first maxes were also equal
	  if((abs(secondmaxf-secondmaxb)/secondmaxf)<percent){
	    totaledepxy[secondmaxchf][secondmaxchb]=totaledep_stripx[secondmaxchf];
	    maxesequal=2;//first and second maxes are both equal
	  }
	  
	}else{
	  if((abs(secondmaxf-secondmaxb)/secondmaxf)<percent){
	    totaledepxy[secondmaxchf][secondmaxchb]=totaledep_stripx[secondmaxchf];
	    secondequal=2;
	  }
	}
	//if(countf==1) cout<<maxf<<" "<<secondmaxf<<" "<<secondmaxb<<endl;//to check that it keeps one 0 and will still increment the other if need be
	//  }//end countf>2
      //third max
	//   if(countf>=3){
	for(int x=1;x<17;x++){
	  //  if(countf==countb){
	  if((totaledep_stripx[x]>thirdmaxf)&&(totaledep_stripx[x]<secondmaxf)){
	    thirdmaxf=totaledep_stripx[x];
	    thirdmaxchf=x;
	  }
	  if((totaledep_stripy[x]>thirdmaxb)&&(totaledep_stripy[x]<secondmaxb)){
	    thirdmaxb=totaledep_stripy[x];
	    thirdmaxchb=x;
	  }
	  //  }
	}
	if(maxesequal==2){//only equate third if all others were equal before
	  if((abs(thirdmaxf-thirdmaxb)/thirdmaxf)<percent){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=totaledep_stripx[thirdmaxchf];
	    maxesequal=3;
	  }
	}else{//so if first max was unequal
	  if((abs(thirdmaxf-thirdmaxb)/thirdmaxf)<percent){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=totaledep_stripx[thirdmaxchf];
	    if(secondequal==2){
	      secondequal=3;
	    }else{
	      thirdequal=3;
	    }
	  }
	}
	//  }//end countf>3
      //fourth max
    //  if(countf>=4){
	for(int x=1;x<17;x++){
	  // if(countf==countb){
	  if((totaledep_stripx[x]>fourthmaxf)&&(totaledep_stripx[x]<thirdmaxf)){
	    fourthmaxf=totaledep_stripx[x];
	    fourthmaxchf=x;
	  }
	  if((totaledep_stripy[x]>fourthmaxb)&&(totaledep_stripy[x]<thirdmaxb)){
	    fourthmaxb=totaledep_stripy[x];
	    fourthmaxchb=x;
	  }
      // }
	}
	if(maxesequal==3){//only equate fourth if all others were equal first
	  if((abs(fourthmaxf-fourthmaxb)/fourthmaxf)<percent){
	    totaledepxy[fourthmaxchf][fourthmaxchb]=totaledep_stripx[fourthmaxchf];
	    maxesequal=4;
	  }
	}
	//  }//end countf>4
    }//end else if countf and countb are not 1
    // cout<<maxesequal<<endl;
   
    if(maxesequal==0){//none of the maxes match
      if((abs((maxf-(secondmaxb+thirdmaxb+fourthmaxb))-(maxb-(secondmaxf+thirdmaxf+fourthmaxf)))/(maxf-(secondmaxb+thirdmaxb+fourthmaxb)))<percent){//end countb==1
	totaledepxy[maxchf][maxchb]=maxb-(secondmaxf+thirdmaxf+fourthmaxf);
	totaledepxy[maxchf][secondmaxchb]=secondmaxb;
	totaledepxy[maxchf][thirdmaxchb]=thirdmaxb;
	totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	totaledepxy[secondmaxchf][maxchb]=secondmaxf;
	totaledepxy[thirdmaxchf][maxchb]=thirdmaxf;
	totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
      }else if(secondequal==2){//so the max channels don't equal, but the second maxes are
	if((abs(maxf-(maxb+thirdmaxb+fourthmaxb))/maxf)<percent){
	    totaledepxy[maxchf][maxchb]=maxb;
	    totaledepxy[maxchf][thirdmaxchb]=thirdmaxb;
	    totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	}
	if((abs(maxb-(maxf+thirdmaxf+fourthmaxf))/maxb)<percent){
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[thirdmaxchf][maxchb]=thirdmaxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	}

      }else if(secondequal==3){//the max channels don't equal, but the third and second maxes do
	if((abs(maxf-(fourthmaxb+maxb))/maxf)<percent){
	  totaledepxy[maxchf][maxchb]=maxb;
	  totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	}
	if((abs(maxb-(maxf+fourthmaxf))/maxb)<percent){
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	}

      }else if(thirdequal==3){//the max and second don't equal, but the third does
	if((abs(maxf-(maxb+secondmaxb+fourthmaxb))/maxf)<percent){
	    totaledepxy[maxchf][maxchb]=maxb;
	    totaledepxy[maxchf][secondmaxchb]=secondmaxb;
	    totaledepxy[maxchf][fourthmaxchb]=fourthmaxb;
	}
	if((abs(maxb-(maxf+secondmaxf+fourthmaxf))/maxb)<percent){
	  totaledepxy[maxchf][maxchb]=maxf;
	  totaledepxy[secondmaxchf][maxchb]=secondmaxf;
	  totaledepxy[fourthmaxchf][maxchb]=fourthmaxf;
	}
      }else{
	testing=1;
      }
      
    }else if(maxesequal==1){//so the maximum energy channels match, but the seccond doesn't
      // if(countf==2){
      if((abs(secondmaxf-(secondmaxb+thirdmaxb+fourthmaxb))/secondmaxf)<percent){//all other events on back are on one line on the front
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;//basically do the same with the second max as I did with the max above
	  totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
      }else if((abs(secondmaxf-(thirdmaxb+fourthmaxb)/secondmaxf))<percent){
	  totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;//basically do the same with the second max as I did with the max above
	  totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	  if((abs(secondmaxb-thirdmaxf)/secondmaxb)<percent){//if the second max on the back does not corropsond to the second max on the front, see if it goes with one of the others
	    totaledepxy[thirdmaxchf][secondmaxchb]=secondmaxb;
	  }else if((abs(secondmaxb-fourthmaxf)/secondmaxb)<percent){
	    totaledepxy[fourthmaxchf][secondmaxchb]=secondmaxb;
	  }else if((abs(secondmaxb-(thirdmaxf+fourthmaxf))/secondmaxb)<percent){//doesn't seem to be many cases of this
	    totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;
	    totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	  }//end checking if the other side's 2nd max is equal to some smaller max on the front
	  //case where the second max is separated from the 
      }else if((abs(secondmaxb-(secondmaxf+thirdmaxf+fourthmaxf))/secondmaxb)<percent){//all other events on front are on one line with the back
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxf;
	  totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;//basically do the same with the second max as I did with the max above
	  totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
      }else if((abs(secondmaxb-(thirdmaxf+fourthmaxf))/secondmaxb)<percent){//all other events on front are on one line with the back
	  totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;//basically do the same with the second max as I did with the max above
	  totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	  if((abs(secondmaxf-thirdmaxb)/secondmaxf)<percent){//if the second max on the back does not corropsond to the second max on the front, see if it goes with one of the others
	    totaledepxy[secondmaxchf][thirdmaxchb]=secondmaxf;
	    
	  }else if((abs(secondmaxf-fourthmaxb)/secondmaxf)<percent){
	    totaledepxy[secondmaxchf][fourthmaxchb]=secondmaxf;
	  }else if((abs(secondmaxf-(thirdmaxb+fourthmaxb))/secondmaxf)<percent){//doesn't seem to be many cases of this
	    totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;
	    totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	  }//end checking if the other side's 2nd max is equal to some smaller max on the back
	  //end for case where other side's 2nd max is the same as a lesser max on the back
      }else if((abs(secondmaxf-(secondmaxb+thirdmaxb))/secondmaxf)<percent){//there's a fourth max, but it's a separate event
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[secondmaxchf][thirdmaxchb]=thirdmaxb;
	  if((abs(fourthmaxb-thirdmaxf)/fourthmaxb)<percent){
	    totaledepxy[thirdmaxchf][fourthmaxchb]=thirdmaxf;
	  }
      }else if((abs(secondmaxb-(secondmaxf+thirdmaxf))/secondmaxb)<percent){//all other events on front are on one line with the back
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxf;
	  totaledepxy[thirdmaxchf][secondmaxchb]=thirdmaxf;
	  if((abs(fourthmaxf-thirdmaxb)/fourthmaxf)<percent){
	    totaledepxy[fourthmaxchf][thirdmaxchb]=thirdmaxb;
	  }
      }else if((abs(secondmaxf-(secondmaxb+fourthmaxb))/secondmaxf)<percent){//there's a fourth max, but it's a separate event
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxb;
	  totaledepxy[secondmaxchf][fourthmaxchb]=fourthmaxb;
	  if((abs(thirdmaxb-thirdmaxf)/thirdmaxb)<percent){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxf;
	  }
      }else if((abs(secondmaxb-(secondmaxf+fourthmaxf))/secondmaxb)<percent){//all other events on front are on one line with the back
	  totaledepxy[secondmaxchf][secondmaxchb]=secondmaxf;
	  totaledepxy[fourthmaxchf][secondmaxchb]=fourthmaxf;
	  if((abs(thirdmaxf-thirdmaxb)/thirdmaxf)<percent){
	    totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxb;
	  }
	}else{
	  testing=1;
	}
	
    }else if(maxesequal==2){//the first two highest match, but the third doesn't
      if((abs(thirdmaxf-(thirdmaxb+fourthmaxb))/thirdmaxf)<percent){
	totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxb;//basically do the same with the second max as I did with the max above
	totaledepxy[thirdmaxchf][fourthmaxchb]=fourthmaxb;
      }else if((abs(thirdmaxb-(thirdmaxf+fourthmaxf))/thirdmaxb)<percent){
	totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxf;//basically do the same with the second max as I did with the max above
	totaledepxy[fourthmaxchf][thirdmaxchb]=fourthmaxf;
      }else if((abs((thirdmaxf-fourthmaxb)-(thirdmaxb-fourthmaxf))/(thirdmaxf-fourthmaxb))<percent){
	totaledepxy[thirdmaxchf][fourthmaxchb]=fourthmaxb;
	totaledepxy[fourthmaxchf][thirdmaxchb]=fourthmaxf;
	totaledepxy[thirdmaxchf][thirdmaxchb]=thirdmaxb-fourthmaxf;
      }else{
	testing=1;
      }
    }else{//end comparing the energy maxes
      testing=1;
    }
      // cout<<"here"<<endl;
      //trying to figure out what things are in the events I'm not IDing
    if(testing==1){//because I think 3 and 4 being one or both equal is covered-there aren't any other ways they can be arranged
	//	cout<<"here2"<<endl;
      if(maxf>10) hGeDSSD->Fill(maxf);
      if(secondmaxf>10)	hGeDSSD->Fill(secondmaxf);
      if(thirdmaxf>10) hGeDSSD->Fill(thirdmaxf);
      if(fourthmaxf>10)	hGeDSSD->Fill(fourthmaxf);
	for(int type=0;type<2;type++){
	  if(type==0){
	    if(maxf>1) helectronx->Fill(totaledepx[type][maxchf]);
	    if(secondmaxf>1) helectronx->Fill(totaledepx[type][secondmaxchf]);
	    if(thirdmaxf>1) helectronx->Fill(totaledepx[type][thirdmaxchf]);
	    if(fourthmaxf>1) helectronx->Fill(totaledepx[type][fourthmaxchf]);
	    if(maxb>1) helectrony->Fill(totaledepy[type][maxchb]);
	    if(secondmaxb>1) helectrony->Fill(totaledepy[type][secondmaxchb]);
	    if(thirdmaxb>1) helectrony->Fill(totaledepy[type][thirdmaxchb]);
	    if(fourthmaxb>1) helectrony->Fill(totaledepy[type][fourthmaxchb]);
	  }
	  if(type==1){
	    if(maxf>1) hnotelectronx->Fill(totaledepx[type][maxchf]);
	    if(secondmaxf>1) hnotelectronx->Fill(totaledepx[type][secondmaxchf]);
	    if(thirdmaxf>1) hnotelectronx->Fill(totaledepx[type][thirdmaxchf]);
	    if(fourthmaxf>1) hnotelectronx->Fill(totaledepx[type][fourthmaxchf]);
	    if(maxb>1) hnotelectrony->Fill(totaledepy[type][maxchb]);
	    if(secondmaxb>1) hnotelectrony->Fill(totaledepy[type][secondmaxchb]);
	    if(thirdmaxb>1) hnotelectrony->Fill(totaledepy[type][thirdmaxchb]);
	    if(fourthmaxb>1) hnotelectrony->Fill(totaledepy[type][fourthmaxchb]);
	  }
	}
    }
####################################################################################################################################
copy of V2
int testing=0;
    double percent=0.10;//making a percentage that I can easily change
    double maxesarrayf[4];//want to store these separately
    double maxesarrayb[4];
    int maxesarraychf[4];//want to store these separately
    int maxesarraychb[4];
    
    for(int x=0;x++;x<4){
	maxesarrayf[x]=0;
	maxesarrayb[x]=0;
	maxesarraychf[x]=20;
	maxesarraychb[x]=20;
    }
    if((countf==1)&&(countb==1)){//start with mult one both way events-we know that the x and y must go together
      totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf];
      testing=1;//this way I can bypass the algorithm below if this was the case
      // cout<<maxb<<" front"<<maxf<<endl;
    }
    else{//if they're not both equal to one-if there's only two/1 etc, it should just keep the higher maxes at 0
      maxesarrayf[0]=maxf;
      maxesarrayb[0]=maxb;
      maxesarraychf[0]=maxchf;
      maxesarraychb[0]=maxchb;
      //cout<<maxb<<" front"<<maxf<<endl;
      //second max
      //  if(countf>=2){
	for(int x=1;x<17;x++){
	  
	  //finding second max
	  if((totaledep_stripx[x]>secondmaxf)&&(totaledep_stripx[x]<maxf)){
	    secondmaxf=totaledep_stripx[x];
	    secondmaxchf=x;
	  }
	  if((totaledep_stripy[x]>secondmaxb)&&(totaledep_stripy[x]<maxb)){
	    secondmaxb=totaledep_stripy[x];
	    secondmaxchb=x;
	  }
	  // }
	}
	maxesarrayf[1]=secondmaxf;
	maxesarrayb[1]=secondmaxb;
	maxesarraychf[1]=secondmaxchf;
	maxesarraychb[1]=secondmaxchb;
	//	cout<<secondmaxb<<" front"<<secondmaxf<<endl;

	for(int x=1;x<17;x++){
	  //  if(countf==countb){
	  if((totaledep_stripx[x]>thirdmaxf)&&(totaledep_stripx[x]<secondmaxf)){
	    thirdmaxf=totaledep_stripx[x];
	    thirdmaxchf=x;
	  }
	  if((totaledep_stripy[x]>thirdmaxb)&&(totaledep_stripy[x]<secondmaxb)){
	    thirdmaxb=totaledep_stripy[x];
	    thirdmaxchb=x;
	  }
	  //  }
	}
	maxesarrayf[2]=thirdmaxf;
	maxesarrayb[2]=thirdmaxb;
	maxesarraychf[2]=thirdmaxchf;
	maxesarraychb[2]=thirdmaxchb;
      //fourth max
    //  if(countf>=4){
	for(int x=1;x<17;x++){
	  // if(countf==countb){
	  if((totaledep_stripx[x]>fourthmaxf)&&(totaledep_stripx[x]<thirdmaxf)){
	    fourthmaxf=totaledep_stripx[x];
	    fourthmaxchf=x;
	  }
	  if((totaledep_stripy[x]>fourthmaxb)&&(totaledep_stripy[x]<thirdmaxb)){
	    fourthmaxb=totaledep_stripy[x];
	    fourthmaxchb=x;
	  }
	  //	  cout<<"three "<<thirdmaxf<<" "<<thirdmaxb<<" ";
	  //	  cout<<"four "<<fourthmaxf<<" "<<fourthmaxb<<endl;
      // }
	}
	maxesarrayf[3]=fourthmaxf;
	maxesarrayb[3]=fourthmaxb;
	maxesarraychf[3]=fourthmaxchf;
	maxesarraychb[3]=fourthmaxchb;
	//  }//end countf>4
    }//end else if countf and countb are not 1
    // cout<<maxesequal<<endl;
    //start algorithm V2
    cout<<"start algorithm"<<endl;
    if(testing!=1){//to  skip over the mult=1 both sides case, where I didn't find any of the maxes
      // cout<<"here1"<<endl;
      for(int x=0;x<4;x++){
	double sumof4=0;
	double sumof3=0;
	double sumof2=0;
	//	double sumof2b=0;
	for(int y=0;y<4;y++){
	  if((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent){
	    //  cout<<"here"<<endl;
	    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
	    cout<<"same"<<x<<" "<<y<<endl;
	    /* maxesarrayf[x]=0;
	    maxesarrayb[y]=0;
	    maxesarraychf[x]=20;
	    maxesarraychb[y]=20;*/
	    }
	  if(y>=x)sumof4+=maxesarrayb[y];//to get the sum of all the y maxima that are the same (i.e. first max or second max) or a lower maxima on the front
	  if(y>x) sumof3+=maxesarrayb[y];//to get the sum of all the y maxima that are less than the current x (maxf=secondb+thirdb+fourthb)
	  if(x<3){
	    if((y<=(x+1))&&(y>(x-1))) sumof2+=maxesarrayb[y];//to get cases like maxf=maxb+2b
	  }
	  /* if(x<2){
	     if((y>x)&&(y<=(x+2))) sumof2b+=maxesarrayb[y];//to get cases like maxf=2b+3b
	     }*/
	  //  cout<<"here3"<<endl;
	  //start with comparing individual channels front and back, if any of the maxes are equal, then put those equal parties in the array
	  if((y<3)&&(x<3)){//should go over all channels, so I shouldn't have to repeat for y loop first, x loop second
	    if((abs((maxesarrayf[x]+maxesarrayf[x+1])-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]+maxesarrayf[x+1]))<percent){//things like maxf+2f=maxb+2b
	      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+1];//intersection of highest channels
	      totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
	      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
	      cout<<"here"<<x<<" "<<y<<endl;
	    }
	  }
	  if((y<2)&&(x<2)){//to compare maxf+3f=maxb+3b, so I don't want to include the 3/4 max, since there isn't a max two lower than it
	    if((abs((maxesarrayf[x]+maxesarrayf[x+2])-(maxesarrayb[y]+maxesarrayb[y+2]))/(maxesarrayf[x]+maxesarrayf[x+2]))<percent){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];//intersection of highest channels
	      totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
	      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
	      cout<<"here1"<<x<<" "<<y<<endl;
	    }
	  }
	  
	}//end of y loop
	if((abs(maxesarrayf[x]-sumof4)/maxesarrayf[x])<percent){//comparing each maxium on the front to the sum of all maxima on the back with the same number or lower
	  totaledepxy[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	  cout<<"here2"<<endl;
	}
	if((abs(maxesarrayf[x]-sumof3)/maxesarrayf[x])<percent){//comparing each maxium on the front to the sum of all maxima on the back with a lower index
	  totaledepxy[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	  cout<<"here3"<<endl;
	}
	if((abs(maxesarrayf[x]-sumof2)/maxesarrayf[x])<percent){//comparing each maxium on the front to the sum of the same max and the next lowest
	  totaledepxy[maxesarraychf[x]][maxesarraychb[x]]=maxesarrayb[x];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[x+1]]=maxesarrayb[x+1];
	  cout<<"here4"<<endl;
	}
	/*	if((abs(maxesarrayf[x]-sumof2b)/maxesarrayf[x])<percent){//comparing each maxium on the front to the sum of the same max and the next lowest
	  totaledepxy[maxesarraychf[x]][maxesarraychb[x+1]]=maxesarrayb[x+1];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[x+2]]=maxesarrayb[x+2];
	  }*/
      }//end of x loop
      //need to do the same for the y's looking at the x sums
      for(int y=0;y<4;y++){
	double sumof4=0;
	double sumof3=0;
	double sumof2=0;
	//	double sumof2b=0;
	for(int x=0;x<4;x++){
	  if(x>=y)sumof4+=maxesarrayf[x];//to get the sum of all the x maxima that are the same (i.e. first max or second max) or a lower maxima on the front
	  if(x>y) sumof3+=maxesarrayf[x];
	  if(y<3){
	    if((x<=(y+1))&&(x>(y-1))) sumof2+=maxesarrayf[x];
	  }
	  /* if(y<2){
	    if((x>y)&&(x<=(y+2))) sumof2b+=maxesarrayb[y];//to get cases like maxf=2b+3b
	    }*/
	}//end of y loop
	if((abs(maxesarrayb[y]-sumof4)/maxesarrayb[y])<percent){//comparing each maxium on the back to the sum of all maxima on the front with the same number or lower
	  totaledepxy[maxesarraychf[0]][maxesarraychb[y]]=maxesarrayf[0];
	  totaledepxy[maxesarraychf[1]][maxesarraychb[y]]=maxesarrayf[1];
	  totaledepxy[maxesarraychf[2]][maxesarraychb[y]]=maxesarrayf[2];
	  totaledepxy[maxesarraychf[3]][maxesarraychb[y]]=maxesarrayf[3];
	  cout<<"here5"<<endl;
	}
	if((abs(maxesarrayb[y]-sumof3)/maxesarrayb[y])<percent){//comparing each maxium on the back to the sum of all on the front  with a lower index
	  totaledepxy[maxesarraychf[1]][maxesarraychb[y]]=maxesarrayf[1];
	  totaledepxy[maxesarraychf[2]][maxesarraychb[y]]=maxesarrayf[2];
	  totaledepxy[maxesarraychf[3]][maxesarraychb[y]]=maxesarrayf[3];
	  cout<<"here6"<<endl;
	}
	if((abs(maxesarrayb[y]-sumof2)/maxesarrayb[y])<percent){//comparing each maxium on the back to the sum of the same max and the next lowest
	  totaledepxy[maxesarraychf[y]][maxesarraychb[y]]=maxesarrayf[y];
	  totaledepxy[maxesarraychf[y+1]][maxesarraychb[y]]=maxesarrayf[y+1];
	  cout<<"here7"<<endl;
	}
	/*if((abs(maxesarrayb[y]-sumof2b)/maxesarrayb[y])<percent){//comparing each maxium on the back to the sum of the same max and the next lowest
	  totaledepxy[maxesarraychf[y+1]][maxesarraychb[y]]=maxesarrayf[y+1];
	  totaledepxy[maxesarraychf[y+2]][maxesarraychb[y]]=maxesarrayf[y+2];
	  }*/
      }//end of y loop

    }//end testing!=1
####################################################################################################################################
copy of algorithm V2.1
if(testing!=1){//to  skip over the mult=1 both sides case, where I didn't find any of the maxes
      // cout<<"here1"<<endl;
      int ymatch[4];
      int xmatch[4];
      for(int y=0;y<4;y++){
	ymatch[y]=0;//will increment these to 1 for each y index that has a matching x somewhere
	xmatch[y]=0;
      }
      for(int x=0;x<4;x++){
	for(int y=0;y<4;y++){
	  int neighborstripx=0;//I think I want this to reset for each y
	  int neighborstripy=0;
	  if((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent){//if the two strips are equal, do this, then go on to the next loop-might actually want to make this neutral in terms of if the strip is neighboring or not
	    for(int c=0;c<4;c++){//trying to compare neighboring strips
	      if(maxesarraychf[c]>0){
		if(abs(maxesarraychf[x]-maxesarraychf[c])==1){//if there's a strip is within 1 of a strip that has a match
		  neighborstripx=1;
		}
	      }
	      if(maxesarraychb[c]>0){
		if(abs(maxesarraychb[y]-maxesarraychb[c])==1){//if the strip is within 1
		  neighborstripy=1;
		}
	      }
	    }
	    if((neighborstripx==0)&&(neighborstripy==0)){//only increment matching strips if neither has another strip right next to it
	      if((maxesarrayf[x]>0)&&(maxesarrayb[y>0])) totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
	      ymatch[y]=1;//keeps track of which maxes had a match to some max on the other side
	      xmatch[x]=1;
	      //we know that all events here do not have any neighbors, so we'll have to pick up those with neighbors later
	      if((x==0)&&(y==0)){
		//cout<<"here"<<endl;
		algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];//want to call the maximum strips electrons
	      }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if it's next to the implant strip
		  if(maxesarrayf[x]>1000){
		    algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		  }else{
		    algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		  }
		//	cout<<"here1"<<endl;
		}else{//if it's somewhere else, call it a gamma.
		algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
	      }
	    }
	    // cout<<"here"<<endl;
	  }
	}//end y loop
      }//end x loop
      //Now to compare and ignore the ones where there's a match to something on the other side
      
      for(int x=0;x<4;x++){
	double runningsumy=0;//want this to reset for each x
	//	cout<<"here1"<<endl;
	double sumxplus1=0;//want these all to reset for each new x
	double sumxplus2=0;
	double sumxplus3=0;
	if(xmatch[x]==0){//see what effect disqualifying events where both the strips were matched to another single strip
	  if(x<3){
	    if((xmatch[x+1]==0)/*&&(abs(maxesarraychf[x]-maxesarraychf[x+1])==1)*/) sumxplus1=maxesarrayf[x]+maxesarrayf[x+1];//try keeping them to neighboring strips-just see if there's a difference between neighboring strips and non-neighboring strips
	  }//calculates the sum of two adjacent x strips
	  if(x<2){
	    if((xmatch[x+2]==0)/*&&(abs(maxesarraychf[x]-maxesarraychf[x+2])==1)*/) sumxplus2=maxesarrayf[x]+maxesarrayf[x+2];
	  }
	  if(x<1){
	    if((xmatch[x+3]==0)/*&&(abs(maxesarraychf[x]-maxesarraychf[x+3])==1)*/) sumxplus3=maxesarrayf[x]+maxesarrayf[x+3];
	  }
	}
	for(int y=0;y<4;y++){
	  if(xmatch[x]==0){
	    if((ymatch[y]==0)/*&&(xmatch[x]==0)*/){//if neither has a match somewhere
	      //  cout<<"here"<<endl;
	      if(maxesarrayb[y]>0){//i.e.e only compare if there actually exists something to compare to-this way it won't match if the xsums are 0
		runningsumy+=maxesarrayb[y];//add all of these y together that aren't in a pair.
		//}
		// cout<<"here2"<<endl;
		if(sumxplus1>0){
	      // cout<<"here3 "<<x<<endl;
		  if((abs(maxesarrayb[y]-sumxplus1)/maxesarrayb[y])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    ymatch[y]=1;
		    xmatch[x+1]=1;
		    xmatch[x]=1;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
		      if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }
		    //for the x+1 strip
		    if((abs(maxesarraychf[0]-maxesarraychf[x+1])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayf[x+1]>1000){
			algorithmelectrons[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      }else{
			algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    }
		    //I think this should just re-fill the same pixels if the event also qualifies for 
		    //cout<<"here "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<endl;
		  }else{
		    double sumyplus1=0;
		    if(y<3){//try to compare the sum on the x with sums on the y-shouldn't have to also do this in the other loop
		      if((ymatch[y+1]==0)&&(maxesarrayb[y+1]>0)) sumyplus1=maxesarrayb[y]+maxesarrayb[y+1];
		      if((sumyplus1!=0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+1])==1)*/){
			if((abs(sumyplus1-sumxplus1)/sumyplus1)<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  ymatch[y]=1;
			  ymatch[y+1]=1;
			  xmatch[x]=1;
			  xmatch[x+1]=1;
			  //try to differentiate electrons and gammas
			  if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			    algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			  }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
			    if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			    }else{//for gammas
			      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			    }
			  }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
			    algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			  }
			  //for the x+1 strip
			  if((abs(maxesarraychf[0]-maxesarraychf[x+1])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//first look if the x+1 strip is a neighbor to the 
			    if(maxesarrayf[x+1]>1000){
			      algorithmelectrons[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			    }else{
			      algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			    }
			  }else{
			    algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  }
			  //for the y+1 strip
			  if((abs(maxesarraychb[0]-maxesarraychb[y+1])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//first look if the x+1 strip is a neighbor to the 
			    if(maxesarrayb[y+1]>1000){
			      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			    }else{
			      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			    }
			  }else{
			    algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  }
			}//end abs
		      }
		    }
		  }//end else
		}//end sumxplus1
		//  cout<<"here4"<<endl;
		if(sumxplus2>0){//I don't think it should be able to be both x+[x+1] and x+[x+2]
		  //  cout<<"here5"<<endl;
		  if((abs(maxesarrayb[y]-sumxplus2)/maxesarrayb[y])<percent){//if the sum of the two maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    ymatch[y]=1;
		    xmatch[x+2]=1;
		    xmatch[x]=1;
		    //  cout<<"here3 "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
		      if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }
		    //for the x+2 strip
		    if((abs(maxesarraychf[0]-maxesarraychf[x+2])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayf[x+2]>1000){
			algorithmelectrons[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }else{
			algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    }
		  }else{
		    double sumyplus2=0;
		    if(y<2){//try to compare the sum on the x with sums on the y-shouldn't have to also do this in the other loop
		      if((ymatch[y+2]==0)&&(maxesarrayb[y+2]>0)) sumyplus2=maxesarrayb[y]+maxesarrayb[y+2];
		      if((sumyplus2!=0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+2])==1)*/){
			if((abs(sumyplus2-sumxplus2)/sumyplus2)<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  ymatch[y]=1;
			  xmatch[x+2]=1;
			  xmatch[x]=1;
			  ymatch[y+2]=1;
			  //try to differentiate gammas and electrons
			  if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			    algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			  }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
			    if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			    }else{//for gammas
			      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			    }
			  }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
			    algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			  }
			  //for the x+2 strip
			  if((abs(maxesarraychf[0]-maxesarraychf[x+2])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//first look if the x+1 strip is a neighbor to the 
			    if(maxesarrayf[x+2]>1000){
			      algorithmelectrons[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			    }else{
			      algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			    }
			  }else{
			    algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  }
			  //for the y+2 strip
			  if((abs(maxesarraychb[0]-maxesarraychb[y+2])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//first look if the x+1 strip is a neighbor to the 
			    if(maxesarrayb[y+2]>1000){
			      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			    }else{
			      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			    }
			  }else{
			    algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  }
			}//end abs
		      }
		    }
		  }//end else
		}//end sumxplus2
		//	cout<<"here6"<<endl;
		if(sumxplus3>0){
		  //	  cout<<"here7"<<endl;
		  if((abs(maxesarrayb[y]-sumxplus3)/maxesarrayb[y])<percent){//if the sum of the two maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    xmatch[x+3]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    //  cout<<"here3 "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
		      if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }
		    //for the x+3 strip
		    if((abs(maxesarraychf[0]-maxesarraychf[x+3])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayf[x+3]>1000){
			algorithmelectrons[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }else{
			algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    }
		  }else{
		    double sumyplus3=0;
		    if(y<1){//try to compare the sum on the x with sums on the y-shouldn't have to also do this in the other loop
		      if((ymatch[y+3]==0)&&(maxesarrayb[y+3]>0)) sumyplus3=maxesarrayb[y]+maxesarrayb[y+3];
		      if((sumyplus3!=0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+3])==1)*/){
			if((abs(sumyplus3-sumxplus3)/sumyplus3)<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  xmatch[x+3]=1;
			  xmatch[x]=1;
			  ymatch[y]=1;
			  ymatch[y+3]=1;
			  //try to differentiate gammas and electrons
			  if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			    algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			  }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
			    if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			    }else{//for gammas
			      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			    }
			  }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
			    algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			  }
			  //for the x+3 strip
			  if((abs(maxesarraychf[0]-maxesarraychf[x+3])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//first look if the x+1 strip is a neighbor to the 
			    if(maxesarrayf[x+3]>1000){
			      algorithmelectrons[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			    }else{
			      algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			    }
			  }else{
			    algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  }
			  //for the y+3 strip
			  if((abs(maxesarraychb[0]-maxesarraychb[y+3])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//first look if the x+1 strip is a neighbor to the 
			    if(maxesarrayb[y+3]>1000){
			      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			    }else{
			      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			    }
			  }else{
			    algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  }
			}//end abs
		      }
		    }
		  }//end else
		}//end sumxplus3
		//	cout<<"here8"<<endl;
	      }//end maxesarrayb>0
	    }//end match y 
	  }//end match x
	  
	}//end y loop
	//	cout<<"here"<<endl;
	if(xmatch[x]==0){
	  if((abs(maxesarrayf[x]-runningsumy)/maxesarrayf[x])<percent){//for each x that didn't have a pair, compare it to the running total of all the other non-paired y's
	    if((ymatch[0]==0)&&(maxesarrayb[0]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	      ymatch[0]=1;
	      xmatch[x]=1;
	    }
	    if((ymatch[1]==0)&&(maxesarrayb[1]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
	      ymatch[1]=1;
	      xmatch[x]=1;
	    }
	    if((ymatch[2]==0)&&(maxesarrayb[2]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
	      ymatch[2]=1;
	      xmatch[x]=1;
	    }
	    if((ymatch[3]==0)&&(maxesarrayb[3]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	      ymatch[3]=1;
	      xmatch[x]=1;
	    }
	    for(int c=0;c<4;c++){
	      //try to differentiate gammas and electrons
	      if((x==0)&&(c==0)){//if these strips happen to be the max energy strips-should only possibly be able to find this once
		algorithmelectrons[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	      }else if((abs(maxesarraychb[0]-maxesarraychb[c])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//if they are nearest neighbor strips
		if(maxesarrayb[c]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[c]]=maxesarrayb[c];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[c]]==maxesarrayb[c];
		}
	      }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[c]]==maxesarrayb[c];
	      }
	    }//end for c
	    
	    //  cout<<"here2 "<<x<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[0]]<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[1]]<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[2]]<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[3]]<<endl;
	  }//end abs
	  /*if(xmatch[x+1]<4){
	    if(xmatch[x+1]==0){
	      if((abs(maxesarrayf[x]+maxesarrayf[x+1]-runningsumy)/maxesarrayf[x])<percent){//comparing two, non-macthing strips to the sum of all the others
	      }
	    }//ens xmatch+1
	    }*/
	}//end xmatch
      }//end x loop
      
      for(int y=0;y<4;y++){
	double runningsumx=0;//want this to reset for each x
	double sumyplus1=0;
	double sumyplus2=0;
	double sumyplus3=0;
	if(ymatch[y]==0){
	  if(y<3){
	    if((ymatch[y+1]==0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+1])==1)*/) sumyplus1=maxesarrayb[y]+maxesarrayb[y+1];//calculates the sum of two adjacent x strips
	  }
	  if(y<2){
	    if((ymatch[y+2]==0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+2])==1)*/) sumyplus2=maxesarrayb[y]+maxesarrayb[y+2];
	  }
	  if(y<1){
	    if((ymatch[y+3]==0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+3])==1)*/) sumyplus2=maxesarrayb[y]+maxesarrayb[y+3];
	  }
	}
	for(int x=0;x<4;x++){
	  if(ymatch[y]==0){
	    if(/*(ymatch[y]==0)&&*/(xmatch[x]==0)){//if neither has a match somewhere
	    // cout<<"here"<<endl;
	      if(maxesarrayf[x]>0){
		runningsumx+=maxesarrayf[x];//add all of these y together that aren't in a pair. 
	    // }
		if(sumyplus1>0){
		  if((abs(maxesarrayf[x]-sumyplus1)/maxesarrayf[x])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+1]=1;		    
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychb[0]-maxesarraychb[y])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//if they are nearest neighbor strips
		      if(maxesarrayb[y]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    }
		    //for the y+1 strip
		    if((abs(maxesarraychb[0]-maxesarraychb[y+1])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayb[y+1]>1000){
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    }
		  }
		}//end sumyplus1
	      if(sumyplus2>0){
		  if((abs(maxesarrayf[x]-sumyplus2)/maxesarrayf[x])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+2]=1;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychb[0]-maxesarraychb[y])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//if they are nearest neighbor strips
		      if(maxesarrayb[y]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    }
		    //for the y+2 strip
		    if((abs(maxesarraychb[0]-maxesarraychb[y+2])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayb[y+2]>1000){
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    }
		  }
		}//end sumyplus2
		if(sumyplus3>0){
		  if((abs(maxesarrayf[x]-sumyplus3)/maxesarrayf[x])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+3]=1;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychb[0]-maxesarraychb[y])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//if they are nearest neighbor strips
		      if(maxesarrayb[y]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    }
		    //for the y+3 strip
		    if((abs(maxesarraychb[0]-maxesarraychb[y+3])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])==1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayb[y+3]>1000){
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    }
		  }
		}//end sumyplus3
	      }//end maxesarray>0
	    }//end match x are 0
	  }//end y match
	}//end y loop
	if(ymatch[y]==0){
	  if((abs(maxesarrayb[y]-runningsumx)/maxesarrayb[y])<percent){//for each x that didn't have a pair, compare it to the running total of all the other non-paired y's
	    if((xmatch[0]==0)&&(maxesarrayf[0]>0)){
	      totaledepxy[maxesarraychf[0]][maxesarraychb[y]]=maxesarrayf[0];
	      ymatch[y]=1;
	      xmatch[0]=1;
	    }
	    if((xmatch[1]==0)&&(maxesarrayf[1]>0)){
	      totaledepxy[maxesarraychf[1]][maxesarraychb[y]]=maxesarrayf[1];
	      ymatch[y]=1;
	      xmatch[1]=1;
	    }
	    if((xmatch[2]==0)&&(maxesarrayf[2]>0)){
	      totaledepxy[maxesarraychf[2]][maxesarraychb[y]]=maxesarrayf[2];
	      ymatch[y]=1;
	      xmatch[2]=1;
	    }
	    if((xmatch[3]==0)&&(maxesarrayf[3]>0)){
	      totaledepxy[maxesarraychf[3]][maxesarraychb[y]]=maxesarrayf[3];
	      ymatch[y]=1;
	      xmatch[3]=1;
	    }
	    for(int c=0;c<4;c++){
	      //try to differentiate gammas and electrons
	      if((c==0)&&(y==0)){//if these strips happen to be the max energy strips-should only possibly be able to find this once
		algorithmelectrons[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0];
	      }else if((abs(maxesarraychf[0]-maxesarraychf[c])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
		if(maxesarrayb[c]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[c]][maxesarraychb[y]]=maxesarrayf[c];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[c]][maxesarraychb[y]]==maxesarrayf[c];
		}
	      }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		algorithmgammas[maxesarraychf[c]][maxesarraychb[y]]==maxesarrayb[c];
	      }
	    }//end for c
	  }//end abs
	}//end ymatch
	}//end x loop
      for(int x=0;x<4;x++){//allowing both the following loops will give an idea of how much I'm missing by only looking at the fourth highest maxes and which are being missed in the algorithm right now
	if(ymatch[x]==0){
	  if(maxesarrayb[x]>5) hGeDSSD->Fill(maxesarrayb[x]);//prob. don't need to fill for both x and y
	  //hMult1x->Fill(countb);
	  if(maxesarrayb[x]>5) hMult1x->Fill(maxesarraychb[x]);
	}
      }
      for(int t =1;t<17;t++){//will look at all other channels
	if((t!=maxesarraychf[0])&&(t!=maxesarraychf[1])&&(t!=maxesarraychf[2])&&(t!=maxesarraychf[3])){
	  if(totaledep_stripx[t]>5) hGeDSSD->Fill(totaledep_stripx[t]);
	}
      }
    }//end testing!=1
####################################################################################################################################
Copy of V2.2 (aka what I'm showing at the committee meeting
int testing=0;
    double percent=0.05;//making a percentage that I can easily change
    int maxnumber=5;
    double maxesarrayf[maxnumber];//want to store these separately
    double maxesarrayb[maxnumber];
    int maxesarraychf[maxnumber];//want to store these separately
    int maxesarraychb[maxnumber];
    
    for(int x=0;x<maxnumber;x++){
	maxesarrayf[x]=0;
	maxesarrayb[x]=0;
	maxesarraychf[x]=20;
	maxesarraychb[x]=20;
    }
    if((countf==1)&&(countb==1)){//start with mult one both way events-we know that the x and y must go together
      totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf];
      testing=1;//this way I can bypass the algorithm below if this was the case
      maxesarrayf[0]=maxf;
      maxesarrayb[0]=maxb;
      maxesarraychf[0]=maxchf;
      maxesarraychb[0]=maxchb;
      algorithmelectrons[maxchf][maxchb]=maxf;

      // cout<<maxb<<" front"<<maxf<<endl;
    }
    else{//if they're not both equal to one-if there's only two/1 etc, it should just keep the higher maxes at 0
      maxesarrayf[0]=maxf;
      maxesarrayb[0]=maxb;
      maxesarraychf[0]=maxchf;
      maxesarraychb[0]=maxchb;
      //cout<<maxb<<" front"<<maxf<<endl;
      //second max
      //  if(countf>=2){
	for(int x=1;x<17;x++){
	  
	  //finding second max
	  if((totaledep_stripx[x]>maxesarrayf[1])&&(totaledep_stripx[x]<maxesarrayf[0])){
	    maxesarrayf[1]=totaledep_stripx[x];
	    maxesarraychf[1]=x;
	  }
	  if((totaledep_stripy[x]>maxesarrayb[1])&&(totaledep_stripy[x]<maxesarrayb[0])){
	    maxesarrayb[1]=totaledep_stripy[x];
	    maxesarraychb[1]=x;
	  }
	  // }
	}
	//	cout<<secondmaxb<<" front"<<secondmaxf<<endl;
	//third max
	for(int x=1;x<17;x++){
	  //  if(countf==countb){
	  if((totaledep_stripx[x]>maxesarrayf[2])&&(totaledep_stripx[x]<maxesarrayf[1])){
	    maxesarrayf[2]=totaledep_stripx[x];
	    maxesarraychf[2]=x;
	  }
	  if((totaledep_stripy[x]>maxesarrayb[2])&&(totaledep_stripy[x]<maxesarrayb[1])){
	    maxesarrayb[2]=totaledep_stripy[x];
	    maxesarraychb[2]=x;
	  }
	  //  }
	}
	//fourth max
    //  if(countf>=4){
	for(int x=1;x<17;x++){
	  // if(countf==countb){
	  if((totaledep_stripx[x]>maxesarrayf[3])&&(totaledep_stripx[x]<maxesarrayf[2])){
	    maxesarrayf[3]=totaledep_stripx[x];
	    maxesarraychf[3]=x;
	  }
	  if((totaledep_stripy[x]>maxesarrayb[3])&&(totaledep_stripy[x]<maxesarrayb[2])){
	    maxesarrayb[3]=totaledep_stripy[x];
	    maxesarraychb[3]=x;
	  }
	  //	  cout<<"three "<<thirdmaxf<<" "<<thirdmaxb<<" ";
	  //	  cout<<"four "<<fourthmaxf<<" "<<fourthmaxb<<endl;
      // }
	}
	//fifth max
	for(int x=1;x<17;x++){
	  // if(countf==countb){
	  if((totaledep_stripx[x]>maxesarrayf[4])&&(totaledep_stripx[x]<maxesarrayf[3])){
	    maxesarrayf[4]=totaledep_stripx[x];
	    maxesarraychf[4]=x;
	  }
	  if((totaledep_stripy[x]>maxesarrayb[4])&&(totaledep_stripy[x]<maxesarrayb[3])){
	    maxesarrayb[4]=totaledep_stripy[x];
	    maxesarraychb[4]=x;
	  }
	  //	  cout<<"three "<<thirdmaxf<<" "<<thirdmaxb<<" ";
	  //	  cout<<"four "<<fourthmaxf<<" "<<fourthmaxb<<endl;
      // }
	}
	
	//  }//end countf>4
    }//end else if countf and countb are not 1
    // cout<<maxesequal<<endl;
    //start algorithm V2.1
    /* cout<<"start algorithm"<<endl;
    cout<<"max "<<maxf<<" "<<maxb<<" ";
    cout<<"two "<<secondmaxf<<" "<<secondmaxb<<endl;
    cout<<"three "<<thirdmaxf<<" "<<thirdmaxb<<" ";
    cout<<"four "<<fourthmaxf<<" "<<fourthmaxb<<endl;*/
    if(testing!=1){//to  skip over the mult=1 both sides case, where I didn't find any of the maxes
      // cout<<"here1"<<endl;
      int ymatch[maxnumber];
      int xmatch[maxnumber];
      for(int y=0;y<maxnumber;y++){
	ymatch[y]=0;//will increment these to 1 for each y index that has a matching x somewhere
	xmatch[y]=0;
      }
      for(int x=0;x<maxnumber;x++){
	for(int y=0;y<maxnumber;y++){
	  int neighborstripx=0;//I think I want this to reset for each y
	  int neighborstripy=0;
	  if((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent){//if the two strips are equal, do this, then go on to the next loop-might actually want to make this neutral in terms of if the strip is neighboring or not
	    for(int c=0;c<maxnumber;c++){//trying to compare neighboring strips
	      if(maxesarraychf[c]>0){
		if(abs(maxesarraychf[x]-maxesarraychf[c])==1){//if there's a strip is within 1 of a strip that has a match
		  neighborstripx=1;
		}
	      }
	      if(maxesarraychb[c]>0){
		if(abs(maxesarraychb[y]-maxesarraychb[c])==1){//if the strip is within 1
		  neighborstripy=1;
		}
	      }
	    }
	    if((neighborstripx==0)&&(neighborstripy==0)){//only increment matching strips if neither has another strip right next to it
	      if((maxesarrayf[x]>0)&&(maxesarrayb[y>0])) totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
	      ymatch[y]=1;//keeps track of which maxes had a match to some max on the other side
	      xmatch[x]=1;
	      //we know that all events here do not have any neighbors, so we'll have to pick up those with neighbors later
	      if((x==0)&&(y==0)){
		//cout<<"here"<<endl;
		algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];//want to call the maximum strips electrons
	      }else if((abs(maxesarraychf[0]-maxesarraychf[x])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if it's next to the implant strip
		  if(maxesarrayf[x]>1000){
		    algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		  }else{
		    algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		  }
		//	cout<<"here1"<<endl;
		}else{//if it's somewhere else, call it a gamma.
		algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
	      }
	    }
	    // cout<<"here"<<endl;
	  }
	}//end y loop
      }//end x loop
      //Now to compare and ignore the ones where there's a match to something on the other side
      
      for(int x=0;x<maxnumber;x++){
	//	double runningsumy=0;//want this to reset for each x
	//	cout<<"here1"<<endl;
	double sumxplus1=0;//want these all to reset for each new x
	double sumxplus2=0;
	double sumxplus3=0;
	if(xmatch[x]==0){//see what effect disqualifying events where both the strips were matched to another single strip
	  if(x<maxnumber-1){
	    if((xmatch[x+1]==0)&&(maxesarrayf[x+1]>0)) sumxplus1=maxesarrayf[x]+maxesarrayf[x+1];
	  }
	  if(x<maxnumber-2){
	    if((xmatch[x+2]==0)&&(maxesarrayf[x+2]>0)) sumxplus2=maxesarrayf[x]+maxesarrayf[x+2];
	  }
	  if(x<maxnumber-3){
	    if((xmatch[x+3]==0)&&(maxesarrayf[x+3]>0)) sumxplus3=maxesarrayf[x]+maxesarrayf[x+3];
	  }
	}
	for(int y=0;y<maxnumber;y++){
	  double sumyplus1=0;
	  double sumyplus2=0;
	  double sumyplus3=0;
	  if(xmatch[x]==0){
	    if((ymatch[y]==0)/*&&(xmatch[x]==0)*/){//if neither has a match somewhere
	      //  cout<<"here"<<endl;
	      if(maxesarrayb[y]>0){//i.e.e only compare if there actually exists something to compare to-this way it won't match if the xsums are 0
		//I can compare pairs of y with pairs of x
		if(y<maxnumber-1){
		  if((ymatch[y+1]==0)&&(maxesarrayb[y+1]>0)) sumyplus1=maxesarrayb[y]+maxesarrayb[y+1];
		}//calculates the sum of two adjacent x strips
		if(y<maxnumber-2){
		  if((ymatch[y+2]==0)&&(maxesarrayb[y+2]>0)) sumyplus2=maxesarrayb[y]+maxesarrayb[y+2];
		}
		if(y<maxnumber-3){
		  if((ymatch[y+3]==0)&&(maxesarrayb[y+3]>0)) sumyplus3=maxesarrayb[y]+maxesarrayb[y+3];
		}
		
		//}
		// cout<<"here2"<<endl;
		if(sumxplus1>0){
	      // cout<<"here3 "<<x<<endl;
		  if((abs(maxesarrayb[y]-sumxplus1)/maxesarrayb[y])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    ymatch[y]=1;
		    xmatch[x+1]=1;
		    xmatch[x]=1;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
		      if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }
		    //for the x+1 strip
		    if((abs(maxesarraychf[0]-maxesarraychf[x+1])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayf[x+1]>1000){
			algorithmelectrons[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      }else{
			algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    }
		    //I think this should just re-fill the same pixels if the event also qualifies for 
		    //cout<<"here "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<endl;
		  }else if((sumyplus1!=0)){//if the sum of the x+1 isn't equal to the single y, compare it to all the sums of the y's
		    if((abs(sumyplus1-sumxplus1)/sumyplus1)<percent){
		      //   int choice=gRandom->Integer(11);
		      //  if(choice>=0){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      // }else{
		      /*	if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarraychb[y];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1]-maxesarrayf[x+1];
			  
			}else{
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarraychf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[y+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1]-maxesarrayb[y+1];
			  }
			  }*/
		      ymatch[y]=1;
		      ymatch[y+1]=1;
		      xmatch[x]=1;
		      xmatch[x+1]=1;
		      //to figure out what these events actually look like and then compare to the algorithm
		      /*   if(totaldep[0][maxesarraychf[x]][maxesarraychb[y]]>5) helectrony->Fill(totaldep[0][maxesarraychf[x]][maxesarraychb[y]]);
		      if(totaldep[1][maxesarraychf[x]][maxesarraychb[y]]>5) hnotelectrony->Fill(totaldep[1][maxesarraychf[x]][maxesarraychb[y]]);
		      if(totaldep[0][maxesarraychf[x+1]][maxesarraychb[y]]>5) helectrony->Fill(totaldep[0][maxesarraychf[x+1]][maxesarraychb[y]]);
		      if(totaldep[1][maxesarraychf[x+1]][maxesarraychb[y]]>5) hnotelectrony->Fill(totaldep[1][maxesarraychf[x+1]][maxesarraychb[y]]);
		      if(totaldep[0][maxesarraychf[x]][maxesarraychb[y+1]]>5) helectrony->Fill(totaldep[0][maxesarraychf[x]][maxesarraychb[y+1]]);
		      if(totaldep[1][maxesarraychf[x]][maxesarraychb[y+1]]>5) hnotelectrony->Fill(totaldep[1][maxesarraychf[x]][maxesarraychb[y+1]]);*/
		      //try to differentiate electrons and gammas
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			//	helectronx->Fill(maxesarrayf[x]-maxesarraychb[y+1]);
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			  //	  helectronx->Fill(maxesarrayf[x]-maxesarraychb[y+1]);
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			  //  hnotelectronx->Fill(maxesarrayf[x]-maxesarraychb[y+1]);
			}
		      }else {//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			//	hnotelectronx->Fill(maxesarrayf[x]-maxesarraychb[y+1]);
		      }
		      //for the x+1 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+1])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+1]>1000){
			  algorithmelectrons[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  //  helectronx->Fill(maxesarrayf[x+1]);
			}else{
			  algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  // hnotelectronx->Fill(maxesarrayf[x+1]);
			}
		      }else{
			algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			//	hnotelectronx->Fill(maxesarrayf[x+1]);
		      }
		      //for the y+1 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+1])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+1]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  // helectronx->Fill(maxesarrayb[y+1]);
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  //  hnotelectronx->Fill(maxesarrayb[y+1]);
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			//	hnotelectronx->Fill(maxesarrayb[y+1]);
		      }
		    }//end abs
		    /*  }else if(sumyplus2!=0){
		    if((abs(sumyplus2-sumxplus1)/sumyplus2)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];
		      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      ymatch[y]=1;
		      ymatch[y+2]=1;
		      xmatch[x]=1;
		      xmatch[x+1]=1;
		      //try to differentiate electrons and gammas
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];
			}
		      }else{//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];
		      }
		      //for the x+1 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+1])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+1]>1000){
			  algorithmelectrons[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			}else{
			  algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      }
		      //for the y+2 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+2])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+2]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }
		    }//end abs
		  }else if(sumyplus3!=0){
		    if((abs(sumyplus3-sumxplus1)/sumyplus2)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      ymatch[y]=1;
		      ymatch[y+3]=1;
		      xmatch[x]=1;
		      xmatch[x+1]=1;
		      //try to differentiate electrons and gammas
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			}
		      }else {//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      }
		      //for the x+1 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+1])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+1]>1000){
			  algorithmelectrons[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			}else{
			  algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      }
		      //for the y+3 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+3])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+3]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			
		      }
		      
		      }//end abs*/
		  }//end else if's for sumypluses
		}//end sumxplus1
	      //  cout<<"here4"<<endl;
	      if(sumxplus2>0){//I don't think it should be able to be both x+[x+1] and x+[x+2]
		  //  cout<<"here5"<<endl;
		  if((abs(maxesarrayb[y]-sumxplus2)/maxesarrayb[y])<percent){//if the sum of the two maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    ymatch[y]=1;
		    xmatch[x+2]=1;
		    xmatch[x]=1;
		    //  cout<<"here3 "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
		      if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }
		    //for the x+2 strip
		    if((abs(maxesarraychf[0]-maxesarraychf[x+2])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayf[x+2]>1000){
			algorithmelectrons[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }else{
			algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    }
		  }else if((sumyplus2!=0)){//again, looking at all the sums of y's compared to x's
		    if((abs(sumyplus2-sumxplus2)/sumyplus2)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      ymatch[y]=1;
		      xmatch[x+2]=1;
		      xmatch[x]=1;
		      ymatch[y+2]=1;
		      //try to differentiate gammas and electrons
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			}
		      }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      }
		      //for the x+2 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+2])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+2]>1000){
			  algorithmelectrons[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			}else{
			  algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }
		      //for the y+2 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+2])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+2]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }
		    }//end abs
		    /*}else if(sumyplus1!=0){
		    if((abs(sumyplus1-sumxplus2)/sumyplus1)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      ymatch[y]=1;
		      xmatch[x+2]=1;
		      xmatch[x]=1;
		      ymatch[y+1]=1;
		      //try to differentiate gammas and electrons
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			}
		      }else {//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      }
		      //for the x+2 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+2])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+2]>1000){
			  algorithmelectrons[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			}else{
			  algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }
		      //for the y+1 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+1])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+1]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      }
		    }//end abs
		    
		  }else if(sumyplus3!=0){
		    if((abs(sumyplus3-sumxplus2)/sumyplus3)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      ymatch[y]=1;
		      xmatch[x+2]=1;
		      xmatch[x]=1;
		      ymatch[y+3]=1;
		      //try to differentiate gammas and electrons
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			}
		      }else {//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      }
		      //for the x+2 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+2])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+2]>1000){
			  algorithmelectrons[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			}else{
			  algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      }
		      //for the y+3 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+3])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+3]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+3];
		      }
		      }//end abs*/
		  }
	      }//end sumxplus2
		//	cout<<"here6"<<endl;
		if(sumxplus3>0){
		  //	  cout<<"here7"<<endl;
		  if((abs(maxesarrayb[y]-sumxplus3)/maxesarrayb[y])<percent){//if the sum of the two maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    xmatch[x+3]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    //  cout<<"here3 "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
		      if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }
		    //for the x+3 strip
		    if((abs(maxesarraychf[0]-maxesarraychf[x+3])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayf[x+3]>1000){
			algorithmelectrons[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }else{
			algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    }
		  }else if((sumyplus3!=0)){//again, looking for the sums of the y's to be equal to the sum's of the x's
		    if((abs(sumyplus3-sumxplus3)/sumyplus3)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      xmatch[x+3]=1;
		      xmatch[x]=1;
		      ymatch[y]=1;
		      ymatch[y+3]=1;
		      //try to differentiate gammas and electrons
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			}
		      }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      }
		      //for the x+3 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+3])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+3]>1000){
			  algorithmelectrons[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			}else{
			  algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }
		      //for the y+3 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+3])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+3]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      }
		    }//end abs
		    /* }else if(sumyplus1!=0){
		    if((abs(sumyplus1-sumxplus3)/sumyplus1)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      xmatch[x+3]=1;
		      xmatch[x]=1;
		      ymatch[y]=1;
		      ymatch[y+1]=1;
		      //try to differentiate gammas and electrons
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			}
		      }else {//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      }
		      //for the x+3 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+3])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+3]>1000){
			  algorithmelectrons[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			}else{
			  algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }
		      //for the y+1 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+1])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+1]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      }
		    }//end abs
		  }else if(sumyplus2!=0){
		    if((abs(sumyplus2-sumxplus3)/sumyplus2)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      xmatch[x+3]=1;
		      xmatch[x]=1;
		      ymatch[y]=1;
		      ymatch[y+2]=1;
		      //try to differentiate gammas and electrons
		      if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
			if(maxesarrayf[x]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			}else{//for gammas
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
			}
		      }else {//if they are farther away 
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      }
		      //for the x+3 strip
		      if((abs(maxesarraychf[0]-maxesarraychf[x+3])==1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayf[x+3]>1000){
			  algorithmelectrons[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			}else{
			  algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			}
		      }else{
			algorithmgammas[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      }
		      //for the y+2 strip
		      if((abs(maxesarraychb[0]-maxesarraychb[y+2])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
			if(maxesarrayb[y+2]>1000){
			  algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			}else{
			  algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			}
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }
		      }//end abs*/
		  }
		}//end sumxplus3
		//	cout<<"here8"<<endl;
	      }//end maxesarrayb>0
	    }//end match y 
	    // if(ymatch[y]==0) runningsumy+=maxesarrayb[y];//add all of these y together that aren't in a pair-if they didn't match in a sum above
	  }//end match x
	  
	}//end y loop
	//	cout<<"here"<<endl;
	/*	if(xmatch[x]==0){
	  if((abs(maxesarrayf[x]-runningsumy)/maxesarrayf[x])<percent){//for each x that didn't have a pair, compare it to the running total of all the other non-paired y's
	    if((ymatch[0]==0)&&(maxesarrayb[0]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	      ymatch[0]=1;
	      xmatch[x]=1;
	      if((x==0)){//if these strips happen to be the max energy strips-should only possibly be able to find this once
		algorithmelectrons[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[0]]==maxesarrayb[0];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[0]]==maxesarrayb[0];
	      }
	    }
	    if((ymatch[1]==0)&&(maxesarrayb[1]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
	      ymatch[1]=1;
	      xmatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[1])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[1]]==maxesarrayb[1];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[1]]==maxesarrayb[1];
	      }
	    }
	    if((ymatch[2]==0)&&(maxesarrayb[2]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
	      ymatch[2]=1;
	      xmatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[2])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[2]]==maxesarrayb[2];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[2]]==maxesarrayb[2];
	      }
	    }
	    if((ymatch[3]==0)&&(maxesarrayb[3]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	      ymatch[3]=1;
	      xmatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[3])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[3]]==maxesarrayb[3];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[3]]==maxesarrayb[3];
	      }
	    }
	    
	    
	    //  cout<<"here2 "<<x<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[0]]<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[1]]<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[2]]<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[3]]<<endl;
	  }//end abs
	  /*if(xmatch[x+1]<4){
	    if(xmatch[x+1]==0){
	      if((abs(maxesarrayf[x]+maxesarrayf[x+1]-runningsumy)/maxesarrayf[x])<percent){//comparing two, non-macthing strips to the sum of all the others
	      }
	    }//ens xmatch+1
	    }
      }//end xmatch*/
      }//end x loop
      
      for(int y=0;y<maxnumber;y++){
	//	double runningsumx=0;//want this to reset for each x
	double sumyplus1=0;
	double sumyplus2=0;
	double sumyplus3=0;
	if(ymatch[y]==0){
	  if(y<maxnumber-1){
	    if((ymatch[y+1]==0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+1])==1)*/) sumyplus1=maxesarrayb[y]+maxesarrayb[y+1];//calculates the sum of two adjacent x strips
	  }
	  if(y<maxnumber-2){
	    if((ymatch[y+2]==0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+2])==1)*/) sumyplus2=maxesarrayb[y]+maxesarrayb[y+2];
	  }
	  if(y<maxnumber-3){
	    if((ymatch[y+3]==0)/*&&(abs(maxesarraychb[y]-maxesarraychb[y+3])==1)*/) sumyplus2=maxesarrayb[y]+maxesarrayb[y+3];
	  }
	}
	for(int x=0;x<maxnumber;x++){
	  if(ymatch[y]==0){
	    if(/*(ymatch[y]==0)&&*/(xmatch[x]==0)){//if neither has a match somewhere
	    // cout<<"here"<<endl;
	      if(maxesarrayf[x]>0){
		// }
		if(sumyplus1>0){
		  if((abs(maxesarrayf[x]-sumyplus1)/maxesarrayf[x])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+1]=1;		    
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychb[0]-maxesarraychb[y])<=1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//if they are nearest neighbor strips
		      if(maxesarrayb[y]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    }
		    //for the y+1 strip
		    if((abs(maxesarraychb[0]-maxesarraychb[y+1])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayb[y+1]>1000){
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    }
		  }
		}//end sumyplus1
	      if(sumyplus2>0){
		  if((abs(maxesarrayf[x]-sumyplus2)/maxesarrayf[x])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+2]=1;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychb[0]-maxesarraychb[y])<=1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//if they are nearest neighbor strips
		      if(maxesarrayb[y]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    }
		    //for the y+2 strip
		    if((abs(maxesarraychb[0]-maxesarraychb[y+2])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayb[y+2]>1000){
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    }
		  }
		}//end sumyplus2
		if(sumyplus3>0){
		  if((abs(maxesarrayf[x]-sumyplus3)/maxesarrayf[x])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+3]=1;
		    //try to differentiate gammas and electrons
		    if((x==0)&&(y==0)){//if these strips happen to be the max energy strips
		      algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    }else if((abs(maxesarraychb[0]-maxesarraychb[y])<=1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//if they are nearest neighbor strips
		      if(maxesarrayb[y]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }else{//for gammas
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      }
		    }else /*if(maxesarrayf[x]<1000)*/{//if they are farther away 
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    }
		    //for the y+3 strip
		    if((abs(maxesarraychb[0]-maxesarraychb[y+3])==1)&&(abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//first look if the x+1 strip is a neighbor to the 
		      if(maxesarrayb[y+3]>1000){
			algorithmelectrons[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      }else{
			algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      }
		    }else{
		      algorithmgammas[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    }
		  }
		}//end sumyplus3
	      }//end maxesarray>0
	    }//end match x are 0
	    // if(xmatch==0) runningsumx+=maxesarrayf[x];//add all of these y together that aren't in a pair. 
	  }//end y match
	}//end x loop
	/*	if(ymatch[y]==0){
	  if((abs(maxesarrayb[y]-runningsumx)/maxesarrayb[y])<percent){//for each x that didn't have a pair, compare it to the running total of all the other non-paired y's
	    if((xmatch[0]==0)&&(maxesarrayf[0]>0)){
	      totaledepxy[maxesarraychf[0]][maxesarraychb[y]]=maxesarrayf[0];
	      ymatch[y]=1;
	      xmatch[0]=1;
	      if((y==0)){//if these strips happen to be the max energy strips-should only possibly be able to find this once
		algorithmelectrons[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0];
	      }else if((abs(maxesarraychb[0]-maxesarraychb[y])==1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[0]][maxesarraychb[y]]=maxesarrayf[0];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[0]][maxesarraychb[y]]==maxesarrayf[0];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[0]][maxesarraychb[y]]==maxesarrayb[0];
	      }
	    }
	    if((xmatch[1]==0)&&(maxesarrayf[1]>0)){
	      totaledepxy[maxesarraychf[1]][maxesarraychb[y]]=maxesarrayf[1];
	      ymatch[y]=1;
	      xmatch[1]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[1])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[1]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[1]][maxesarraychb[y]]=maxesarrayf[1];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[1]][maxesarraychb[y]]==maxesarrayf[1];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[1]][maxesarraychb[y]]==maxesarrayb[1];
	      }
	    }
	    if((xmatch[2]==0)&&(maxesarrayf[2]>0)){
	      totaledepxy[maxesarraychf[2]][maxesarraychb[y]]=maxesarrayf[2];
	      ymatch[y]=1;
	      xmatch[2]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[2])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[2]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[2]][maxesarraychb[y]]=maxesarrayf[2];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[2]][maxesarraychb[y]]==maxesarrayf[2];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[2]][maxesarraychb[y]]==maxesarrayb[2];
	      }
	    }
	    if((xmatch[3]==0)&&(maxesarrayf[3]>0)){
	      totaledepxy[maxesarraychf[3]][maxesarraychb[y]]=maxesarrayf[3];
	      ymatch[y]=1;
	      xmatch[3]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[3])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[y])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[3]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[3]][maxesarraychb[y]]=maxesarrayf[3];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[3]][maxesarraychb[y]]==maxesarrayf[3];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[3]][maxesarraychb[y]]==maxesarrayb[3];
	      }
	    }
	  }//end abs
	  }//end ymatch*/
	}//end y loop

      double runningsumy=0;
      double runningsumx=0;
      for(int x=0;x<maxnumber;x++){
	if((xmatch[x]==0)&&(maxesarrayf[x]>0)) runningsumx+=maxesarrayf[x];
    	if((ymatch[x]==0)&&(maxesarrayb[x]>0)) runningsumy+=maxesarrayb[x];
    }

      /*  for(int x=0; x<maxnumber;x++){
      if(ymatch[x]==0){//only look at y channels that haven't been matched to compare to the x sum
	if((abs(runningsumx-maxesarrayb[x])/maxesarrayb[x])<percent){
	  if((xmatch[0]==0)&&(maxesarrayf[0]>0)){//if 0th channel is part of the running x sum
	      totaledepxy[maxesarraychf[0]][maxesarraychb[x]]=maxesarrayf[0];
	      ymatch[x]=1;
	      xmatch[0]=1;
	      if((x==0)){//if these strips happen to be the max energy strips-should only possibly be able to find this once
		algorithmelectrons[maxesarraychf[0]][maxesarraychb[x]]=maxesarrayf[0];
	      }else if((abs(maxesarraychb[0]-maxesarraychb[x])<=1)){//if they are nearest neighbor strips-we know x is 0, so only need to look at y
		if(maxesarrayf[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[0]][maxesarraychb[x]]=maxesarrayf[0];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[0]][maxesarraychb[x]]=maxesarrayf[0];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[0]][maxesarraychb[x]]=maxesarrayf[0];
	      }
	    }
	    if((xmatch[1]==0)&&(maxesarrayf[1]>0)){
	      totaledepxy[maxesarraychf[1]][maxesarraychb[x]]=maxesarrayf[1];
	      xmatch[1]=1;
	      ymatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[1])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[x])<=1)){//if they are nearest neighbor strips
		if(maxesarrayf[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[1]][maxesarraychb[x]]=maxesarrayf[1];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[1]][maxesarraychb[x]]=maxesarrayf[1];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[1]][maxesarraychb[x]]=maxesarrayf[1];
	      }
	    }
	    if((xmatch[2]==0)&&(maxesarrayf[2]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayf[2];
	      xmatch[2]=1;
	      ymatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[2])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[x])<=1)){//if they are nearest neighbor strips
		if(maxesarrayf[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[2]][maxesarraychb[x]]=maxesarrayf[2];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[2]][maxesarraychb[x]]=maxesarrayf[2];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[2]][maxesarraychb[x]]=maxesarrayf[2];
	      }
	      
	    }
	    if((xmatch[3]==0)&&(maxesarrayf[3]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayf[3];
	      xmatch[3]=1;
	      ymatch[x]=1;
	     if((abs(maxesarraychf[0]-maxesarraychf[3])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[x])<=1)){//if they are nearest neighbor strips
		if(maxesarrayf[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[3]][maxesarraychb[x]]=maxesarrayf[3];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[3]][maxesarraychb[x]]=maxesarrayf[3];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[3]][maxesarraychb[x]]=maxesarrayf[3];
	      } 
	     
	    }
	    if((xmatch[4]==0)&&(maxesarrayf[4]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[4]]=maxesarrayf[4];
	      xmatch[4]=1;
	      ymatch[x]=1;
	     if((abs(maxesarraychf[0]-maxesarraychf[4])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[x])<=1)){//if they are nearest neighbor strips
		if(maxesarrayf[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[4]][maxesarraychb[x]]=maxesarrayf[4];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[4]][maxesarraychb[x]]=maxesarrayf[4];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[4]][maxesarraychb[x]]=maxesarrayf[4];
	      } 
	     
	    }
	}//end abs
      }//end ymatch
      if(xmatch[x]==0){//only look at y channels that haven't been matched to compare to the x sum
	if((abs(runningsumy-maxesarrayf[x])/maxesarrayf[x])<percent){
	  // cout<<"here"<<endl;
	  if((ymatch[0]==0)&&(maxesarrayb[0]>0)){//if 0th channel is part of the running x sum
	      totaledepxy[maxesarraychf[0]][maxesarraychb[x]]=maxesarrayb[0];
	      ymatch[0]=1;
	      xmatch[x]=1;
	      if((x==0)){//if these strips happen to be the max energy strips-should only possibly be able to find this once
		algorithmelectrons[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	      }else if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)){//if they are nearest neighbor strips-we know x is 0, so only need to look at y
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayb[0];
	      }
	    }
	    if((ymatch[1]==0)&&(maxesarrayb[1]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
	      ymatch[1]=1;
	      xmatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[1])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[1]]=maxesarrayb[1];
	      }
	    }
	    if((ymatch[2]==0)&&(maxesarrayb[2]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
	      ymatch[2]=1;
	      xmatch[x]=1;
	      if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[2])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[2]]=maxesarrayb[2];
	      }
	      
	    }
	    if((ymatch[3]==0)&&(maxesarrayb[3]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	      ymatch[3]=1;
	      xmatch[x]=1;
	     if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[3])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	      } 
	     
	    }
	    if((ymatch[4]==0)&&(maxesarrayb[4]>0)){
	      totaledepxy[maxesarraychf[x]][maxesarraychb[4]]=maxesarrayb[4];
	      ymatch[4]=1;
	      xmatch[x]=1;
	     if((abs(maxesarraychf[0]-maxesarraychf[x])<=1)&&(abs(maxesarraychb[0]-maxesarraychb[4])<=1)){//if they are nearest neighbor strips
		if(maxesarrayb[0]>1000){//if this energy is a nearest neighbor and has an energy bigger than 1 MeV
		  algorithmelectrons[maxesarraychf[x]][maxesarraychb[4]]=maxesarrayb[4];
		}else{//for gammas
		  algorithmgammas[maxesarraychf[x]][maxesarraychb[4]]=maxesarrayb[4];
		}
	      }else{//if they are farther away 
		algorithmgammas[maxesarraychf[x]][maxesarraychb[4]]=maxesarrayb[4];
	      } 
	     
	    }
	}//end abs
	}//end xmatch*/
      /*   for(int y=0; y<4;y++){
	  if((y<2)&&(x<3)){
	    //   cout<<"here"<<endl;
	    if((ymatch[y]==0)&&(ymatch[y+1]==0)&&(ymatch[y+2]==0)&&(xmatch[x]==0)&&(xmatch[x+1]==0)){
	      //   cout<<"here1"<<endl;
	      // if((abs((maxesarrayf[x]+maxesarrayf[x+1])-(maxesarrayb[y]+maxesarrayb[y+1]+maxesarrayb[y+2]))/(maxesarrayf[x]+maxesarrayf[x+1]))<percent){
	      //	cout<<"here2"<<endl;
		if((abs(((maxesarrayf[x]-maxesarrayb[y+1])+(maxesarrayf[x+1]-maxesarrayb[y+2]))-maxesarrayb[y])/maxesarrayb[y+2])<percent){
		  //cout<<"here3"<<endl;
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[x]-maxesarrayb[y+1];
		  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayb[x+1]-maxesarrayb[y+2];
		  ymatch[y]=1;
		  ymatch[y+1]=1;
		  ymatch[y+2]=1;
		  xmatch[x]=1;
		  xmatch[x+1]=1;
		}else if((abs(((maxesarrayf[x]-maxesarrayb[y+2])+(maxesarrayf[x+1]-maxesarrayb[y+1]))-maxesarrayb[y])/maxesarrayb[y+2])<percent){
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[x]-maxesarrayb[y+2];
		  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayb[x+1]-maxesarrayb[y+1];
		  ymatch[y]=1;
		  ymatch[y+1]=1;
		  ymatch[y+2]=1;
		  xmatch[x]=1;
		  xmatch[x+1]=1;
		}
		// }
	    }
	    
	  }//end y<2 and x<3
	  if((x<2)&&(y<3)){//same as the above, but reversing the x and y positions
	    if((ymatch[y]==0)&&(ymatch[y+1]==0)&&(xmatch[x+2]==0)&&(xmatch[x]==0)&&(xmatch[x+1]==0)){
	      if((abs((maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+2])-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+2]))<percent){
		
	      }
	      //totaledepxy[maxesarraychf[x]][maxesarraychb[3]]=maxesarrayb[3];
	    }
	    
	  }
	  
	  }//end y for
      
    }//end x for*/
    //want to compare whatever's left over as one item on one side to the sum of everything left on the other
      for(int x=0;x<maxnumber;x++){//allowing both the following loops will give an idea of how much I'm missing by only looking at the fourth highest maxes and which are being missed in the algorithm right now
	if(xmatch[x]==0){
	  if(maxesarrayf[x]>5) hGeDSSD->Fill(maxesarrayf[x]);//prob. don't need to fill for both x and y
	  //hMult1x->Fill(countb);
	  if(maxesarrayf[x]>5) hMult1x->Fill(maxesarraychf[x]);
	}
      }
      for(int t =1;t<17;t++){//will look at all other channels
	if((t!=maxesarraychf[0])&&(t!=maxesarraychf[1])&&(t!=maxesarraychf[2])&&(t!=maxesarraychf[3])){
	  if(totaledep_stripx[t]>5) hGeDSSD->Fill(totaledep_stripx[t]);
	}
      }
    }//end testing!=1
    //hEnergyDeposit->Fill(maxf);
    if(countf==1) hBackMultforFrontMult1->Fill(countb);
    if(countf==2) hBackMultforFrontMult2->Fill(countb);
    //  if(countf==countb){//try for only events with even number of multiplicity, so I don't have to worry about unmatched mults quite yet
    //  totaledepxy[maxchf][maxchb]=totaledep_stripx[maxchf];
    // totaledepxy[secondmaxchf][secondmaxchb]=totaledep_stripx[secondmaxchf];
    // totaledepxy[thirdmaxchf][thirdmaxchb]=totaledep_stripx[thirdmaxchf];
    // totaledepxy[fourthmaxchf][fourthmaxchb]=totaledep_stripx[fourthmaxchf];
      // }

      
    // if(stripimpy==maxchb) helectrony->Fill(maxb);
    // if(stripimpx==maxchf) helectronx->Fill(maxf);

    //if(maxf>20) hGeDSSD->Fill(maxf);//plot of maximum energy channel only to compare to exp
    //if(secondmaxf>20) hGeDSSDsecondmax->Fill(secondmaxf);//plot of the second highest energy channel

    /* for(int x=1;x<17;x++){
      int y=x-1;
      if((maxchf!=y)&&(totaledep_stripx[x]>20)){//match exp lower thresh
	//	hEnergyDeposit->Fill(totaledep_stripx[x]);//plot of all channels except max energy channel
	//	if(totaledep_stripx[x]>20) hEnergyDepositGeDSSDx[y]->Fill(totaledep_stripx[x]);//see what spectra look like if we only put in non-max E events
      }
    }
    // if(tot>0) hEnergyDeposit->Fill(tot);
    // cout<<tot<<endl;totaledepxy
 
      for(int x=1;x<17;x++){//determining dmax for xy events//don't need to give resolution twice
	for(int y=1;y<17;y++){
	  if(totaledepxy[x][y]>maxxy){
	    maxxy=totaledepxy[x][y];
	    maxchx=x-1;//real strip no
	    maxchy=y-1;//real strip no
	    
	  }
	  if(totaledepxy[x][y]>20){
	    if(totaledepxy[x][y]>300) {//add a resolution
	      totaledepxy[x][y]= gRandom->Gaus(totaledepxy[x][y],(0.01*totaledepxy[x][y]/2.35));//from 662 after
	    }else{
	      totaledepxy[x][y] = gRandom->Gaus(totaledepxy[x][y],(0.03*totaledepxy[x][y]/2.35));//from123 after
	    }
	    //hEnergyDepositGeDSSDxy[x-1][y-1]->Fill(totaledepxy[x][y]);//filling up histograms for the 2-D keeping track of energies
	    hGeDSSD->Fill(totaledepxy[x][y]);//all events
	  }
	}
	}*/
    double electronsumx=0;
    double electronsumy=0;
    // cout<<"implant location x "<<maxesarraychf[0]<<" y "<<maxesarraychb[0]<<endl;
    // cout<<"defined by algorithm"<<endl;
    for(int x=1;x<17;x++){//histogramming all events not in the maximum energy pixel
	for(int y=1;y<17;y++){
	  if(totaledepxy[x][y]>20){
	    //if((y!=maxchy+1) && (x!=maxchx+1)) hEnergyDeposit->Fill(totaledepxy[x][y]);
	    //if((y!=stripimpy+1) && (x!=stripimpx+1)) hEnergyDeposit->Fill(totaledepxy[x][y]);
	    //if((y!=9) && (x!=7)) hEnergyDeposit->Fill(totaledepxy[x][y]);
	    // if(x!=maxchf) {
	    hEnergyDepositGeDSSDx[x-1]->Fill(totaledepxy[x][y]);//want to put in "real" strip numbers
	    hEnergyDeposit->Fill(totaledepxy[x][y]);
	    hEnergyDepositGeDSSDy[y-1]->Fill(totaledepxy[x][y]);
	  }
	  // cout<<"here"<<endl;
	  //could do this as strips too-which I would fill like the above, but for now the x and y should look the same
	  if(algorithmelectrons[x][y]>20){
	    // cout<<"here2"<<endl;
	    helectronx->Fill(algorithmelectrons[x][y]);
	    //  electronsumx+=algorithmelectrons[x][y];
	    helectrony->Fill(algorithmelectrons[x][y]);
	    // cout<<"electron "<<algorithmelectrons[x][y]<<" x "<<x <<" y "<<y<<endl;
	  }
	  if(algorithmgammas[x][y]>20){
	    //  cout<<"here1"<<endl;
	    hnotelectronx->Fill(algorithmgammas[x][y]);
	    hnotelectrony->Fill(algorithmgammas[x][y]);
	    // cout<<"gamma "<<algorithmgammas[x][y]<<" x "<<x <<" y "<<y<<endl;
	    //  }
	  }
	}
    }
#############################################################################################################################################
copy of V2.3. As is, it has an efficiency of 14.5-7%
if(testing!=1){//to  skip over the mult=1 both sides case, where I didn't find any of the maxes
      // cout<<"here1"<<endl;
      int ymatch[maxnumber];
      int xmatch[maxnumber];
      for(int y=0;y<maxnumber;y++){
	ymatch[y]=0;//will increment these to 1 for each y index that has a matching x somewhere
	xmatch[y]=0;
      }
      for(int x=0;x<maxnumber;x++){
	if(maxesarrayf[x]==0) xmatch[x]=1;
	if(maxesarrayb[x]==0) ymatch[x]=1;
      }

      for(int x=0;x<maxnumber;x++){
	for(int y=0;y<maxnumber;y++){
	  int neighborstripx=0;//I think I want this to reset for each y
	  int neighborstripy=0;
	  if((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent){//if the two strips are equal, do this, then go on to the next loop-might actually want to make this neutral in terms of if the strip is neighboring or not
	    for(int c=0;c<maxnumber;c++){//trying to compare neighboring strips-want to try comparing to the amount of energy in the other strips, rather than that they're neighboring
	      if((maxesarrayf[c]>0)/*&&(c>x)*/){//only want to compare to higher in E maxima
		if(abs(maxesarraychf[x]-maxesarraychf[c])==1){//if there's a strip is within 1 of a strip that has a match
		  //if((maxesarrayf[c]/maxesarrayf[x])<percent){//if there's a strip that has less than 1% of the energy of this strip
		  //Try with both requirements
		  //if((abs(maxesarraychf[x]-maxesarraychf[c])==1)&&((maxesarrayf[c]/maxesarrayf[x])<percent)){
		  neighborstripx=1;
		}
	      }
		if((maxesarrayb[c]>0)/*&&(c>y)*/){
		  if(abs(maxesarraychb[y]-maxesarraychb[c])==1){//if the strip is within 1
		  //if((maxesarrayb[c]/maxesarrayb[y])<percent){//if the strip is within 1
		  //if((abs(maxesarraychb[y]-maxesarraychb[c])==1)&&((maxesarrayb[c]/maxesarrayb[y])<percent)){
		  neighborstripy=1;
		}
	      }
	    }
	    if((neighborstripx==0)&&(neighborstripy==0)){//only increment matching strips if neither has another strip right next to it-increment if not more than one direction has a neighboring strip
	      if((maxesarrayf[x]>0)&&(maxesarrayb[y>0])){
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		ymatch[y]=1;//keeps track of which maxes had a match to some max on the other side
		xmatch[x]=1;
		//	cout<<"1 : 1"<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<endl;
	      }
	      //we know that all events here do not have any neighbors, so we'll have to pick up those with neighbors later
	    }//else if((neighborstripx==1)||(neighborstripy==1)){//if only one direction has a neighbor, see what that does to the effic
	    //if((maxesarrayf[x]>0)&&(maxesarrayb[y>0])){
	    //totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
	    //ymatch[y]=1;//keeps track of which maxes had a match to some max on the other side
	    //xmatch[x]=1;
	    //}
	    //}
	    // cout<<"here"<<endl;
	  }
	}//end y loop
      }//end x loop
      //Now to compare and ignore the ones where there's a match to something on the other side
      
      for(int x=0;x<maxnumber;x++){
	//	double runningsumy=0;//want this to reset for each x
	//	cout<<"here1"<<endl;
	double sumxplus1=0;//want these all to reset for each new x
	double sumxplus2=0;
	double sumxplus3=0;
	double sumxthree=0;//sum of three in the x direction
	double sumxfour=0;
	double sumxthree2=0;
	double sumxthree3=0;
	if(maxesarrayf[x]>0){
	  if(xmatch[x]==0){//see what effect disqualifying events where both the strips were matched to another single strip
	    //should I add in a maxesarray[x]>0?
	    if(x<maxnumber-1){
	      if((xmatch[x+1]==0)&&(maxesarrayf[x+1]>0)){
		/*	if(abs(maxesarraychf[x]-maxesarraychf[x+1])==1)*/ sumxplus1=maxesarrayf[x]+maxesarrayf[x+1];
	      }
	      if(x<maxnumber-3){
		    if((xmatch[x+3]==0)&&(maxesarrayf[x+3]>0)){//so that if it's not 0,1,2, it can be 0,1,3
			sumxthree3=sumxplus1+maxesarrayf[x+3];
		      }
		    }
	    }
	    if(x<maxnumber-2){
	      if((xmatch[x+2]==0)&&(maxesarrayf[x+2]>0)){
		/*	if(abs(maxesarraychf[x]-maxesarraychf[x+2])==1){*/
		  sumxplus2=maxesarrayf[x]+maxesarrayf[x+2];
		  if((xmatch[x+1]==0)&&(maxesarrayf[x+1]>0)){
		  /* if((abs(maxesarraychf[x+1]-maxesarraychf[x+2])==1)||(abs(maxesarraychf[x+1]-maxesarraychf[x])==1)) */sumxthree=sumxplus2+maxesarrayf[x+1];//s plus x+1 plus x+2
		  }
		  if(x<maxnumber-3){
		    if((xmatch[x+3]==0)&&(maxesarrayf[x+3]>0)){//so that if it's not 0,1,2, it can be 0,2,3
			sumxthree2=sumxplus2+maxesarrayf[x+3];
		      }
		    }
		}
	     // }
	    }
	    if(x<maxnumber-3){
	      if((xmatch[x+3]==0)&&(maxesarrayf[x+3]>0)){
		/*if(abs(maxesarraychf[x]-maxesarraychf[x+3])==1){*/
		  sumxplus3=maxesarrayf[x]+maxesarrayf[x+3];
		  if(sumxthree>0)  sumxfour=sumxthree+maxesarrayf[x+3];//don't think I need the channel here, since if there are three in a row already, and this new one also fits with the x channel-wise
		  }
	      // }
	    }
	  }//end xmatch
	  for(int y=0;y<maxnumber;y++){
	    double sumyplus1=0;
	    double sumyplus2=0;
	    double sumyplus3=0;
	    if(maxesarrayb[y]>0){//i.e.e only compare if there actually exists something to compare to-this way it won't match if the xsums are 0
	      // if(xmatch[x]==0){
	      //  if((ymatch[y]==0)/*&&(xmatch[x]==0)*/){//if neither has a match somewhere
	      //  cout<<"here"<<endl;
	      if(ymatch[y]==0){
		//I can compare pairs of y with pairs of x
		if(y<maxnumber-1){
		  if((ymatch[y+1]==0)&&(maxesarrayb[y+1]>0)){
		    /* if(abs(maxesarraychb[y]-maxesarraychb[y+1])==1)*/ sumyplus1=maxesarrayb[y]+maxesarrayb[y+1];
		  }
		}//calculates the sum of two adjacent x strips
		if(y<maxnumber-2){
		  if((ymatch[y+2]==0)&&(maxesarrayb[y+2]>0)){
		    /*if(abs(maxesarraychb[y]-maxesarraychb[y+2])==1)*/ sumyplus2=maxesarrayb[y]+maxesarrayb[y+2];
		  }
		}
		if(y<maxnumber-3){
		  if((ymatch[y+3]==0)&&(maxesarrayb[y+3]>0)){
		    /*if(abs(maxesarraychb[y]-maxesarraychb[y+2])==1)*/ sumyplus3=maxesarrayb[y]+maxesarrayb[y+3];
		  }
		}
		
	      }//end ymatch
	      if((ymatch[y]==0)&&(xmatch[x]==0)&&(xmatch[x+1]==0)&&(xmatch[x+2]==0)){//want to try going from most strips involved to least strips involved
		if(sumxfour>0){//want to check this one first, since if four were summed, three were also summed
		  if(((abs(maxesarrayb[y]-sumxfour)/maxesarrayb[y])<percent)&&(xmatch[x+3]==0)){//so if one in the y direction equals the sum of four in the x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    xmatch[x+1]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    xmatch[x+2]=1;
		    xmatch[x+3]=1;
		    //  cout<<"y:x, x+1, x+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<< "x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<" x+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<" x+4 "<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]<<endl;
		  }//end abs
		}else if(sumxthree>0){
		  if((abs(maxesarrayb[y]-sumxthree)/maxesarrayb[y])<percent){//so if one in the y direction equals the sum of three in the x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    xmatch[x+1]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    ymatch[x+2]=1;
		    //  cout<<"y:x, x+1, x+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<< "x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<" x+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		  }//end abs
		}else if(sumxthree2>0){
		  if((abs(maxesarrayb[y]-sumxthree2)/maxesarrayb[y])<percent){//so if one in the y direction equals the sum of three in the x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    xmatch[x+3]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    ymatch[x+2]=1;
		    //  cout<<"y:x, x+1, x+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<< "x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<" x+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		  }//end abs
		}else if(sumxthree3>0){
		  if((abs(maxesarrayb[y]-sumxthree3)/maxesarrayb[y])<percent){//so if one in the y direction equals the sum of three in the x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    xmatch[x+3]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    ymatch[x+1]=1;
		    //  cout<<"y:x, x+1, x+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<< "x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<" x+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		  }//end abs
		}//end sumxthree2
	      }//end y/x match y,x,x+1,x+2
	      // cout<<"here2"<<endl;

	      if(sumxplus1>0){
		if((ymatch[y]==0)&&(xmatch[x]==0)&&(xmatch[x+1]==0)){
		  // cout<<"here3 "<<x<<endl;
		  if((sumyplus1!=0)){//if the sum of the x+1 isn't equal to the single y, compare it to all the sums of the y's
		    if(((abs(sumyplus1-sumxplus1)/sumyplus1)<percent)&&(ymatch[y+1]==0)){
		      //   cout<<"x "<<x<<" "<<maxesarraychf[x]<<" max x "<<maxesarrayf[x]<<" second max x "<<maxesarrayf[x+1]<<" "<<maxesarraychf[x+1]<<endl;
		      //  cout<<"y "<<y<<" "<<maxesarraychb[y]<<" max y "<<maxesarrayb[y]<<" second max y "<<maxesarrayb[y+1]<<" "<<maxesarraychb[y+1]<<endl;
		      //   int choice=gRandom->Integer(11);
		      //  if(choice>=0){
		      /* totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
			 totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			 totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];*/
		      //hnotelectronx->Fill(maxesarrayf[x+1]);
		      // hnotelectronx->Fill(maxesarrayb[y+1]);
		      // }else{
		      /*if(maxesarrayf[x]>maxesarrayb[y]){
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarraychb[y];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[x+1];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1]-maxesarrayf[x+1];
			hnotelectrony->Fill(maxesarraychb[y]);
			hnotelectrony->Fill(maxesarrayf[x+1]);
			hnotelectrony->Fill(maxesarrayb[y+1]-maxesarrayf[x+1]);
			if((x!=0)&&(y!=0)){
			numberother++;
			}else{
			number0;
			}
			
			}else{
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarraychf[x];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[y+1];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1]-maxesarrayb[y+1];
			hnotelectrony->Fill(maxesarraychf[x]);
			hnotelectrony->Fill(maxesarrayf[y+1]);
			hnotelectrony->Fill(maxesarrayf[x+1]-maxesarrayb[y+1]);
			if((x!=0)&&(y!=0)){
			numberother++;
			}else{
			number0;
			}
			}*/
		      //}
		      ymatch[y]=1;
		      ymatch[y+1]=1;
		      xmatch[x]=1;
		      xmatch[x+1]=1;
		      /*  if(((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent)&&((abs(maxesarrayf[x+1]-maxesarrayb[y+1])/maxesarrayf[x+1])<percent)){ //if these two are both equal to eachother, then they probably should be in a 1:1 case
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[x+1];
			}else{//probably want something here to deal with*/
		      if((x!=0)&&(y!=0)){//"second" way
			//if((maxesarraychf[x]==8)&&(maxesarraychb[y]==9)){
			//	cout<<"max in x "<<x<< " max in y "<<y<<endl;
			numberother++;
			if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1]-maxesarrayf[x+1];
			  //	cout<<"y, y+1 :x, x+1 not 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x/y+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<< endl;
			  
			}else if(maxesarrayb[y]>maxesarrayf[x]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1]-maxesarrayb[y+1];
			  //	cout<<"y, y+1 :x, x+1 not 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x/y+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]<<" x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<endl;
			}
		      }else{//"first" way
			number0++;
			if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  //	cout<<"y, y+1 :x, x+1 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<endl;
			}else{
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  //	cout<<"y, y+1 :x, x+1 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<endl;
			}
			// }
		      }
		    }//end abs
		    /*  }else if(sumyplus2!=0){
			if((abs(sumyplus2-sumxplus1)/sumyplus2)<percent){
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			ymatch[y]=1;
			ymatch[y+2]=1;
			xmatch[x]=1;
			xmatch[x+1]=1;
			}//end abs
			}else if(sumyplus3!=0){
			if((abs(sumyplus3-sumxplus1)/sumyplus2)<percent){
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			ymatch[y]=1;
			ymatch[y+3]=1;
			xmatch[x]=1;
			xmatch[x+1]=1;
			}//end abs*/
		  }else if((abs(maxesarrayb[y]-sumxplus1)/maxesarrayb[y])<percent){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    ymatch[y]=1;
		    xmatch[x+1]=1;
		    xmatch[x]=1;
		    // cout<<"y :x, x+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<< "x+1 "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<endl;
		    //I think this should just re-fill the same pixels if the event also qualifies for 
		    //cout<<"here "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]<<endl;
		  }//end 1 to 2 strip match
		}//end y/x match for y, x, and x+1
	      }//end sumxplus1
	      //  cout<<"here4"<<endl;
	      if(sumxplus2>0){//I don't think it should be able to be both x+[x+1] and x+[x+2]
		if((ymatch[y]==0)&&(xmatch[x]==0)&&(xmatch[x+2]==0)){
		  //  cout<<"here5"<<endl;
		  if((sumyplus2!=0)){//again, looking at all the sums of y's compared to x's
		    if(((abs(sumyplus2-sumxplus2)/sumyplus2)<percent)&&(ymatch[y+2]==0)){
		      //   cout<<"x "<<x<<" "<<maxesarraychf[x]<<" max x "<<maxesarrayf[x]<<" second max x "<<maxesarrayf[x+2]<<" "<<maxesarraychf[x+2]<<endl;
		      //   cout<<"y "<<y<<" "<<maxesarraychb[y]<<" max y "<<maxesarrayb[y]<<" second max y "<<maxesarrayb[y+2]<<" "<<maxesarraychb[y+2]<<endl;
		      ymatch[y]=1;
		      xmatch[x+2]=1;
		      xmatch[x]=1;
		      ymatch[y+2]=1;
		      /*if(((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent)&&((abs(maxesarrayf[x+2]-maxesarrayb[y+2])/maxesarrayf[x+2])<percent)){ //if these two are both equal to eachother, then they probably should be in a 1:1 case
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]=maxesarrayf[x+2];
		
			}else{*/
		      if((x==0)&&(y==0)){
			if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+2];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  //	cout<<"y, y+2 :x, x+2 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
			}else{
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+2];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  //	cout<<"y, y+2 :x, x+2 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
			}
		      }else{
			if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]=maxesarrayf[x+2];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2]-maxesarrayf[x+2];
			  //	cout<<"y, y+2 :x, x+2 not 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x/y+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
			  
			}else{
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2]-maxesarrayb[y+2];
			  //	cout<<"y, y+2 :x, x+2 not 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x/y+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y+2]]<<"yx+2 "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
			}
		      }
		      //  }
		      // }
		           
		    }//end abs
		    /*}else if(sumyplus1!=0){
		      if((abs(sumyplus1-sumxplus2)/sumyplus1)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      ymatch[y]=1;
		      xmatch[x+2]=1;
		      xmatch[x]=1;
		      ymatch[y+1]=1;
		      }//end abs
		    
		      }else if(sumyplus3!=0){
		      if((abs(sumyplus3-sumxplus2)/sumyplus3)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+3];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		      ymatch[y]=1;
		      xmatch[x+2]=1;
		      xmatch[x]=1;
		      ymatch[y+3]=1;
		      }//end abs*/
		  }else  if((abs(maxesarrayb[y]-sumxplus2)/maxesarrayb[y])<percent){//if the sum of the two maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    ymatch[y]=1;
		    xmatch[x+2]=1;
		    xmatch[x]=1;
		    //  cout<<"y :x, x+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+2"<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		    //  cout<<"here3 "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		    
		  }
		}//end x/y match y,x,x+2
	      }//end sumxplus2
	      //	cout<<"here6"<<endl;
	      if(sumxplus3>0){
		if((ymatch[y]==0)&&(xmatch[x]==0)&&(xmatch[x+3]==0)){
if((sumyplus3!=0)){//again, looking for the sums of the y's to be equal to the sum's of the x's
		    if(((abs(sumyplus3-sumxplus3)/sumyplus3)<percent)&&(ymatch[y+3])){
		      // cout<<"x "<<x<<" "<<maxesarraychf[x]<<" max x "<<maxesarrayf[x]<<" second max x "<<maxesarrayf[x+3]<<" "<<maxesarraychf[x+3]<<endl;
		      //  cout<<"y "<<y<<" "<<maxesarraychb[y]<<" max y "<<maxesarrayb[y]<<" second max y "<<maxesarrayb[y+3]<<" "<<maxesarraychb[y+3]<<endl;
		      /*  if(((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent)&&((abs(maxesarrayf[x+3]-maxesarrayb[y+3])/maxesarrayf[x+3])<percent)){ //if these two are both equal to eachother, then they probably should be in a 1:1 case
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			totaledepxy[maxesarraychf[x+3]][maxesarraychb[y+2]]=maxesarrayf[x+3];
		
			}else{*/
		      if((x==0)&&(y==0)){
			if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+3];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  //	cout<<"y, y+3:x, x+3 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+3 "<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]<<" y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]<<endl;
			}else{
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+3];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  //	cout<<"y, y+3:x, x+3 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+3 "<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]<<" y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]<<endl;
			}
		      }else{
			if(maxesarrayf[x]>maxesarrayb[y]){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y+3]]=maxesarrayf[x+3];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3]-maxesarrayf[x+3];
			  //	cout<<"y, y+3:x, x+3 not 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x/y+3 "<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y+3]]<<" y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]<<endl;
			}else{
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3]-maxesarrayb[y+3];
			  //	cout<<"y, y+3:x, x+3 not 0's "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x/y+3 "<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y+3]]<<" x+3 "<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]<<endl;
			}
		      }
		      xmatch[x+3]=1;
		      xmatch[x]=1;
		      ymatch[y]=1;
		      ymatch[y+3]=1;
		    }//end abs
		    /* }else if(sumyplus1!=0){
		    if((abs(sumyplus1-sumxplus3)/sumyplus1)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+1];
		      totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      xmatch[x+3]=1;
		      xmatch[x]=1;
		      ymatch[y]=1;
		      ymatch[y+1]=1;
		      }//end abs
		  }else if(sumyplus2!=0){
		    if((abs(sumyplus2-sumxplus3)/sumyplus2)<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarraychb[y+2];
		      totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		      xmatch[x+3]=1;
		      xmatch[x]=1;
		      ymatch[y]=1;
		      ymatch[y+2]=1;
		      }//end abs*/
		  }else  if((abs(maxesarrayb[y]-sumxplus3)/maxesarrayb[y])<percent){//if the sum of the two maxes equals this y strip, provided they aren't in a
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    xmatch[x+3]=1;
		    xmatch[x]=1;
		    ymatch[y]=1;
		    //   cout<<"y:x, x+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" x+3"<<totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]<<endl;
		    //  cout<<"here3 "<<x<<" " <<y<<" "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" "<<totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]<<endl;
		  }
		}//end y/x match y,x,x+3
	      }//end sumxplus3
	    }//end maxesarrayb>0
	    //  }//end match y 
	    // if(ymatch[y]==0) runningsumy+=maxesarrayb[y];//add all of these y together that aren't in a pair-if they didn't match in a sum above
	    // }//end match x
	    
	  }//end y loop
	}//end maxesx>0
      }//end x loop
      
      for(int y=0;y<maxnumber;y++){
	//	double runningsumx=0;//want this to reset for each x
	double sumyplus1=0;
	double sumyplus2=0;
	double sumyplus3=0;
	double sumythree=0;//to compare 3 in the y with 1 in the x
	double sumythree2=0;
	double sumythree3=0;
	double sumyfour=0;
	if(maxesarrayb[y]>0){
	  if(ymatch[y]==0){
	    if(y<maxnumber-1){
	      if((ymatch[y+1]==0)&&(maxesarraychb[y+1]>0)){
		/*	if(abs(maxesarraychb[y]-maxesarraychb[y+1])==1)*/ sumyplus1=maxesarrayb[y]+maxesarrayb[y+1];//calculates the sum of two adjacent x strips
	      }
	      if(y<maxnumber-3){
		if((ymatch[y+3]==0)&&(maxesarraychb[y+3]>0)){//so it can also be 0,1,3
		      sumythree3=sumyplus1+maxesarrayb[y+3];
		    }
		  }
	    }
	    if(y<maxnumber-2){
	      if((ymatch[y+2]==0)&&(maxesarraychb[y+2]>0)){
		/*	if(abs(maxesarraychb[y]-maxesarraychb[y+2])==1){*/
		  sumyplus2=maxesarrayb[y]+maxesarrayb[y+2];
		  if((ymatch[y+1]==0)&&(maxesarraychb[y+1]>0)){//0.1.2
		    /*if((abs(maxesarraychb[y+1]-maxesarraychb[y+2])==1)||(abs(maxesarraychb[y+1]-maxesarraychb[y])==1))*/ sumythree=sumyplus2+maxesarrayb[y+1];
		  }
		  if(y<maxnumber-3){
		    if((ymatch[y+3]==0)&&(maxesarraychb[y+3]>0)){//0.23
		      sumythree2=sumyplus2+maxesarrayb[y+3];
		    }
		  }
		  //	}
	      }
	      
	    }
	    if(y<maxnumber-3){
	      if((ymatch[y+3]==0)&&(maxesarraychb[y+3]>0)){
		/*if(abs(maxesarraychb[y]-maxesarraychb[y+3])==1){*/
		  sumyplus2=maxesarrayb[y]+maxesarrayb[y+3];
		  if(sumythree>0) sumyfour=sumythree+maxesarrayb[y+3];
		}
	      // }
	    }
	  }
	  for(int x=0;x<maxnumber;x++){
	    // if(ymatch[y]==0){
	    //  if(/*(ymatch[y]==0)&&*/(xmatch[x]==0)){//if neither has a match somewhere
	    // cout<<"here"<<endl;
	    if(maxesarrayf[x]>0){
	      // }
	      if((ymatch[y]==0)&&(ymatch[y+1]==0)&&(ymatch[y+2]==0)&&(xmatch[x])==0){
		if(sumyfour>0){
		  if(((abs(maxesarrayf[x]-sumyfour)/maxesarrayf[x])<percent)&&(ymatch[y+3]==0)){//if three y equals one x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+1]=1;
		    ymatch[y+2]=1;
		    ymatch[y+3]=1;
		    //  cout<<"x:y, y+1, y+2, y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<" y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]<<endl;
		  }//end abs
		}else if(sumythree>0){
		  if((abs(maxesarrayf[x]-sumythree)/maxesarrayf[x])<percent){//if three y equals one x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+1]=1;
		    ymatch[y+2]=1;
		    // cout<<"x:y, y+1, y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
		  }//end abs
		  
		}else if(sumythree2>0){
		  if((abs(maxesarrayf[x]-sumythree2)/maxesarrayf[x])<percent){//if three y equals one x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+3]=1;
		    ymatch[y+2]=1;
		    // cout<<"x:y, y+1, y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
		  }//end abs
		  
		}else if(sumythree3>0){
		  if((abs(maxesarrayf[x]-sumythree3)/maxesarrayf[x])<percent){//if three y equals one x
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    ymatch[y]=1;
		    xmatch[x]=1;
		    ymatch[y+3]=1;
		    ymatch[y+1]=1;
		    // cout<<"x:y, y+1, y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
		  }//end abs
		  
		}//end sumyfour
	      }//end y/x match x, y, y+1, y+2
	      if(sumyplus1>0){
		if(((abs(maxesarrayf[x]-sumyplus1)/maxesarrayf[x])<percent)&&(ymatch[y]==0)&&(ymatch[y+1]==0)&&(xmatch[x]==0)){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		  ymatch[y]=1;
		  xmatch[x]=1;
		  ymatch[y+1]=1;	
		  //  cout<<"x:y, y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+1 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]<<endl;
		}
	      }//end sumyplus1
	      if(sumyplus2>0){
		if(((abs(maxesarrayf[x]-sumyplus2)/maxesarrayf[x])<percent)&&(ymatch[y]==0)&&(ymatch[y+2]==0)&&(xmatch[x]==0)){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		  ymatch[y]=1;
		  xmatch[x]=1;
		  ymatch[y+2]=1;
		  // cout<<"x:y, y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+2 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]<<endl;
		}
	      }//end sumyplus2
	      if(sumyplus3>0){
		if(((abs(maxesarrayf[x]-sumyplus3)/maxesarrayf[x])<percent)&&(ymatch[y]==0)&&(ymatch[y+1]==0)&&(xmatch[x]==0)){//if the sum of the two adjacent maxes equals this y strip, provided they aren't in a
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		  ymatch[y]=1;
		  xmatch[x]=1;
		  ymatch[y+3]=1;
		  // cout<<"x:y, y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y]]<<" y+3 "<<totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]<<endl;
		}
	      }//end sumyplus3
	         
	      
	    }//end maxesarray>0
	    //  }//end match x are 0
	    // if(xmatch==0) runningsumx+=maxesarrayf[x];//add all of these y together that aren't in a pair. 
	    // }//end y match
	  }//end x loop
	}//end maxy>0
      }//end y loop
      //anything left over, one more chance to match 1 to 1 without restriction on not having neighboring channels
      for(int x=0; x<maxnumber;x++){//didn't seem to add on any efficiency
	if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
	  for(int y=0; y<4;y++){
	    if((ymatch[y]==0)&&(maxesarrayb[y]>0)){
	      if((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayf[x])<percent){
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		xmatch[x]=1;
		ymatch[y]=1;
	      }

	    }//end ymatch
	  }//end y for
	}//end xmatch
      }//end x for
    //want to compare whatever's left over as one item on one side to the sum of everything left on the other
      for(int x=0;x<maxnumber;x++){//allowing both the following loops will give an idea of how much I'm missing by only looking at the fourth highest maxes and which are being missed in the algorithm right now
	if(xmatch[x]==0){
	  if(maxesarrayf[x]>5) hGeDSSD->Fill(maxesarrayf[x]);//prob. don't need to fill for both x and y
	  //hMult1x->Fill(countb);
	  if(maxesarrayf[x]>5){
	    hMult1x->Fill(maxesarraychf[x]);
	    //  cout<<"non matching events "<<maxesarrayf[x]<< " x"<<x<<endl;
	  }
	}
	//	if((ymatch[x]==0)&&(maxesarrayb[x]>5)) cout<<"non matching events "<<maxesarrayb[x]<< " y"<<x<<endl;
      }
      //cout<<" "<<endl;
      for(int t =1;t<17;t++){//will look at all other channels
	if((t!=maxesarraychf[0])&&(t!=maxesarraychf[1])&&(t!=maxesarraychf[2])&&(t!=maxesarraychf[3])){
	  if(totaledep_stripx[t]>5) hGeDSSD->Fill(totaledep_stripx[t]);
	}
      }
    }//end testing!=1

#############################################################################################################################################
V3
 if(testing!=1){//to  skip over the mult=1 both sides case, where I didn't find any of the maxes
      // cout<<"here1"<<endl;
      int ymatch[maxnumber];
      int xmatch[maxnumber];
      for(int y=0;y<maxnumber;y++){
	ymatch[y]=0;//will increment these to 1 for each y index that has a matching x somewhere
	xmatch[y]=0;
      }
      if((countf==1)&&(countb>1)){//1:>1
	for(int y=0;y<maxnumber;y++){
	    totaledepxy[maxesarraychf[0]][maxesarraychb[y]]=maxesarrayb[y];
	    hEnergyDepositAlgorithmTest->Fill(maxesarrayb[y]);
	  }

      }else if((countb==1)&&(countf>1)){//>1:1
	for(int x=0;x<maxnumber;x++){
	    totaledepxy[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayf[x];
	    hEnergyDepositAlgorithmTest->Fill(maxesarrayf[x]);
	  }
	/* }else if((countf==2)&&(countb==2)){//it can only be 2 1:1's or 2 by 2's
	
	  if((abs((maxesarrayf[0]+maxesarrayf[1])-(maxesarrayb[0]+maxesarrayb[1]))/(maxesarrayf[0]+maxesarrayf[1]))<percent){
	    if((xmatch[0]==0)&&(ymatch[0]==0)&&(xmatch[1]==0)&&(ymatch[1]==0)){
	      if((abs(maxesarrayf[1]-maxesarrayb[1])/maxesarrayf[1])>percent){//only match up if the second highest strips aren't equal
	      if(maxesarrayf[0]>maxesarrayb[0]){
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];
		totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
	      }else{
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0]-maxesarrayb[1];
		totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
	      }
	      ymatch[0]=1;
	      ymatch[1]=1;
	      xmatch[0]=1;
	      xmatch[1]=1;
	      }else{//otherwise do the 1:1
		totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayb[1];
		xmatch[1]=1;
		ymatch[1]=1;
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
		xmatch[0]=1;
		ymatch[0]=1;
	      }
	   
	    }//end matches
	    
	}
	   for(int x=0;x<2;x++){
	     //if(ymatch[x]==0) cout<<"somehow missed stuff"<<maxesarrayb[x];
	     if(xmatch[x]==0) hEnergyDeposit->Fill(maxesarrayf[x]);// cout<<" "<<maxesarrayf[x]<<endl;
	   }
	*/ }else if((countf==2)&&(countb>1)){//2:>1
	//start with 1:1 that don't have neighbors to get them out of the way
	//	for(int y=0;y<maxnumber;y++){
	 // for(int x=0;x<2;x++){
	   // if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
	     // int neighborf=0;
	     // int neighborb=0;
	     // for(int c=0; c<maxnumber;c++){
	//	if(maxesarrayb[c]>0){
	//	  if(abs(maxesarraychb[c]-maxesarraychb[y])==1) neighborb=1;
	//	}
	//	if(maxesarrayf[c]>0){
	//	  if(abs(maxesarraychf[c]-maxesarraychf[x])==1) neighborf=1;
	//	}

//	      }
//	      if((neighborb==0)&&(neighborf==0)){
//		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
//		ymatch[y]=1;
//		xmatch[x]=1;
//	      }
//	    }
//	  }
//	  }
	//start with the 2:2-can only be 0,1 to 0,1, otherwise it leaves un-matched things open-i think that these will be already taken care of in the previous case
	//	if(countb==2){//only if they're both two-otherwise I'm missing strips
	  if((abs((maxesarrayf[0]+maxesarrayf[1])-(maxesarrayb[0]+maxesarrayb[1]))/(maxesarrayf[0]+maxesarrayf[1]))<percent){
	    if((xmatch[0]==0)&&(ymatch[0]==0)&&(xmatch[1]==0)&&(ymatch[1]==0)){
	      //  if(((maxesarrayf[0]/maxesarrayb[0])<(1-percent))||((maxesarrayf[0]/maxesarrayb[0])>(1+percent))){
	      //	 if(((maxesarrayf[1]/maxesarrayb[1])<(1-percent))||((maxesarrayf[1]/maxesarrayb[1])>(1+percent))){
	    	if(maxesarrayf[0]>maxesarrayb[0]){
		  totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];
		  totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		  totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		  hEnergyDepositTest->Fill(maxesarrayb[1]);
		  hEnergyDepositTest->Fill(maxesarrayf[1]);
		  hEnergyDepositTest->Fill(maxesarrayb[0]-maxesarrayf[1]);
		  /*totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
		    totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayf[1];
		    totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayf[0]-maxesarrayb[1];*/
		}else{
		  totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0]-maxesarrayb[1];
		  totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		  totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		  hEnergyDepositTest->Fill(maxesarrayf[1]);
		  hEnergyDepositTest->Fill(maxesarrayf[0]-maxesarrayb[1]);
		  hEnergyDepositTest->Fill(maxesarrayb[1]);
		  /*	totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0];
			totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayb[1];
			totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];*/
		}
	      ymatch[0]=1;
	      ymatch[1]=1;
	      xmatch[0]=1;
	      xmatch[1]=1;
	      //       }
	     //}else if(((maxesarrayf[1]/maxesarrayb[1])>(1-percent))&&((maxesarrayf[1]/maxesarrayb[1])<(1+percent))){//if the 0's aren't outside of 1, and the 1's are also 1
	//	totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
	//	totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayb[1];
	//	ymatch[0]=1;
	//	ymatch[1]=1;
	//	xmatch[0]=1;
	//	xmatch[1]=1;

	//	}//end if 0's are more than 5% off 1
	    }//end matches
	  }//else{//for events that aren't 2 strips equal to 2 strips
	  //if not, then do 1:2 for each of the spots on the front
	  for(int x=0;x<2;x++){
	    if(xmatch[x]==0){
	      for(int y=0;y<maxnumber;y++){
		if(y<maxnumber-2){//if i'm just doing y, y+1, y+2, no need for max-3-0+1+2
		  if((ymatch[y]==0)&&(ymatch[y+1]==0)&&(ymatch[y+2]==0)){
		      if((maxesarrayb[y+1]>0)&&(maxesarrayb[y+2]>0)){
			if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]+maxesarrayb[y+2]))/(maxesarrayf[x]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  ymatch[y]=1;
			  ymatch[y+1]=1;
			  xmatch[x]=1;
			  ymatch[y+2]=1;
			}
		      }
		    }
	
       		  if((ymatch[y]==0)&&(ymatch[y+1]==0)){//this will make it not re-match if if already did the one before-0+1
		    if(maxesarrayb[y+1]>0){
		      if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]))<percent){
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			ymatch[y]=1;
			ymatch[y+1]=1;
			xmatch[0]=1;
		      }
		    }
		  }
		  if((ymatch[y]==0)&&(ymatch[y+2]==0)){//0+2
		    if(maxesarrayb[y+2]>0){
		      if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+2]))/(maxesarrayf[x]))<percent){
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			ymatch[y]=1;
			ymatch[y+2]=1;
			xmatch[0]=1;
		      }
		    }
		  }
		}//end less than number-2
		/*	if(y<maxnumber-3){//this didn't actually seem to add anymore counts
		    if((ymatch[y]==0)&&(ymatch[y+3]==0)){
		      if(maxesarrayb[y+3]>0){
			if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+3]))/(maxesarrayf[x]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  hEnergyDepositTest->Fill(maxesarrayb[y]);
			  hEnergyDepositTest->Fill(maxesarrayb[y+3]);
			  ymatch[y]=1;
			  ymatch[y+3]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		    }//end less than number -3*/
		//finally, look of 1:1 matches
		if(ymatch[y]==0){//if this y still isn't matched, then try to match it to just the x
		    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      ymatch[y]=1;
		      xmatch[x]=1;
		    }
		  }

	      }//end y loop
	    }//end xmatch=0
	  }//end x loop
	  // }//end for the else after the 2:2
	  //  cout<<"missed in x=2, y>1"<<endl; 
	  //  cout<<"non-matching events"<<endl;
	  int found188=0;
	  for(int x=0;x<maxnumber;x++){//want to find if there's a strip with 188
	    if((xmatch[x]==0)&&(x<2)){
	      if((maxesarrayf[x]<197)&&(maxesarrayf[x]>178)) found188=1;//5% within 188
	      hEnergyDeposit->Fill(maxesarrayf[x]);//I just want to fill all the left over stuff into the histograms
	      hEnergyDepositGeDSSDx[maxesarraychf[x]-1]->Fill(maxesarrayf[x]);
	      hEnergyDepositx->Fill(maxesarrayf[x]);
	    }
	    if((ymatch[x]==0)&&(maxesarrayb[x]>0)){
	      if((maxesarrayb[x]<197)&&(maxesarrayb[x]>178)) found188=1;//5% within 188
	      hEnergyDepositGeDSSDy[maxesarraychb[x]-1]->Fill(maxesarrayb[x]);//algorithm + leftover strips
	      hEnergyDeposity->Fill(maxesarrayb[x]);
	    }
	  }
	  if(found188==1){
	    // printout=1;
	    //  cout<<" "<<endl;
	    for(int x=0;x<maxnumber;x++){
	      if((xmatch[x]==0)&&(x<2)){
		//	hEnergyDeposit->Fill(maxesarrayf[x]);
		//	hEnergyDepositGeDSSDx[maxesarraychf[x]-1]->Fill(maxesarrayf[x]);
		//cout<<"x "<<x<<" "<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
	      }
	      if((ymatch[x]==0)&&(maxesarrayb[x]>0)){
		//	cout<<"y "<<x<<" "<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
		//	hEnergyDepositGeDSSDy[maxesarraychb[x]-1]->Fill(maxesarrayb[x]);
	      }
	    }
	  }else{//see what's leftover
	    // cout<<" "<<endl;
	    for(int x=0;x<maxnumber;x++){
	      if((xmatch[x]==0)&&(x<2)){
		//	printout=1;
		hnotelectrony->Fill(maxesarrayf[x]);
		//	cout<<"x "<<x<<" "<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
	      }
	      if((ymatch[x]==0)&&(maxesarrayb[x]>0)){
		//	printout=1;
		hGeDSSD->Fill(maxesarrayb[x]);
		//	cout<<"y "<<x<<" "<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	      }
	    }
	  }
	//  cout<<"matching events"<<endl;
	 // for(int x=0;x<maxnumber;x++){
	  //  if((xmatch[x]==1)&&(x<2)){
	       //     cout<<maxesarrayf[x]<< " x"<<x<<" "<<maxesarraychf[x]<<endl;
	    //   cout<<"x"<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
	    // }
	    // if((ymatch[x]==1)&&(maxesarrayb[x]>0)){
	       //   cout<<maxesarrayb[x]<< " y"<<x<<" "<<maxesarraychb[x]<<endl;
	      // cout<<"y"<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	    // }
	    // }
	  
      }else if((countb==2)&&(countf>1)){//>1:2
	//start with 1:1 that don't have neighbors to get them out of the way
//		for(int y=0;y<2;y++){
	//  for(int x=0;x<maxnumber;x++){
	  //  if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
	    //  int neighborf=0;
	      //int neighborb=0;
	     // for(int c=0; c<maxnumber;c++){
	//	if(maxesarrayb[c]>0){
	//	  if(abs(maxesarraychb[c]-maxesarraychb[y])==1) neighborb=1;
	//	}
	//	if(maxesarrayf[c]>0){
	//	  if(abs(maxesarraychf[c]-maxesarraychf[x])==1) neighborf=1;
	//	}

	  //    }
	    //  if((neighborb==0)&&(neighborf==0)){
	//	totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
	//	ymatch[y]=1;
	//	xmatch[x]=1;
	  //    }
	    //}
	 // }
	 // }
	//start with the 2:2
	//	if(countf==2){//only if they're both two-otherwise I'm missing strips
	  if((abs((maxesarrayf[0]+maxesarrayf[1])-(maxesarrayb[0]+maxesarrayb[1]))/(maxesarrayf[0]+maxesarrayf[1]))<percent){
	    if((xmatch[0]==0)&&(ymatch[0]==0)&&(xmatch[1]==0)&&(ymatch[1]==0)){
	      // if(((maxesarrayf[0]/maxesarrayb[0])<(1-percent))||((maxesarrayf[0]/maxesarrayb[0])>(1+percent))){
	      // 	if(((maxesarrayf[1]/maxesarrayb[1])<(1-percent))||((maxesarrayf[1]/maxesarrayb[1])>(1+percent))){
	       if(maxesarrayf[0]>maxesarrayb[0]){
		  totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];
		  totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		  totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		  hEnergyDepositTest->Fill(maxesarrayb[1]);
		  hEnergyDepositTest->Fill(maxesarrayf[1]);
		  hEnergyDepositTest->Fill(maxesarrayb[0]-maxesarrayf[1]);
		  /*	totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
			totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayf[1];
			totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayf[0]-maxesarrayb[1];*/
		}else{
		  /*	totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0];
			totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayb[1];
			totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];*/
		  totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0]-maxesarrayb[1];
		  totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		  totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		  hEnergyDepositTest->Fill(maxesarrayf[1]);
		  hEnergyDepositTest->Fill(maxesarrayf[0]-maxesarrayb[1]);
		  hEnergyDepositTest->Fill(maxesarrayb[1]);
		}
	      ymatch[0]=1;
	      ymatch[1]=1;
	      xmatch[0]=1;
	      xmatch[1]=1;
	      //	}
	  // }else if(((maxesarrayf[1]/maxesarrayb[1])>(1-percent))&&((maxesarrayf[1]/maxesarrayb[1])<(1+percent))){//if the 0's aren't outside of 1, and the 1's are also 1
	//	totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
	//	totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayb[1];
	//	ymatch[0]=1;
	//	ymatch[1]=1;
	//	xmatch[0]=1;
	//	xmatch[1]=1;
	//	}
	    }//end matching
	  }//else{
	    //if not, then do 1:2 for each of the spots on the front
	    for(int y=0;y<2;y++){
	      if(ymatch[y]==0){
		for(int x=0;x<maxnumber;x++){
		  if(x<maxnumber-2){
		    if((xmatch[x]==0)&&(xmatch[x+1]==0)&&(xmatch[x+2]==0)){//0+1+2
		      if((maxesarrayf[x+1]>0)&&(maxesarrayf[x+2]>0)){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  ymatch[y]=1;
			  xmatch[x+1]=1;
			  xmatch[x]=1;
			  xmatch[x+2]=1;
			}
		      }
		    }
		    if((xmatch[x]==0)&&(xmatch[x+1]==0)){//0+1
		      if(maxesarrayf[x+1]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  ymatch[y]=1;
			  xmatch[x+1]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		    if((xmatch[x]==0)&&(xmatch[x+2]==0)){//0+2
		      if(maxesarrayf[x+2]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  ymatch[y]=1;
			  xmatch[x+2]=1;
			  xmatch[x]=1;
			}
		      }
		    }

		  }//end less than number-2
		  /*if(x<maxnumber-3){//this didn't actually seem to add anymore counts
		    if((xmatch[x]==0)&&(xmatch[x+3]==0)){
		      if(maxesarrayf[x+3]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+3]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  hEnergyDepositTest->Fill(maxesarrayf[x]);
			  hEnergyDepositTest->Fill(maxesarrayf[x+3]);
			  ymatch[y]=1;
			  xmatch[x+3]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		    }//end less than number -3*/
		  //finally, look of 1:1 matches
		  if(xmatch[x]==0){
		    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      xmatch[x]=1;
		      ymatch[y]=1;
		    }
		  }	    
		}//end x loop
	      }
	    }//end y loop
	    
	    // }//end for the else for the 2:2 above
	    // cout<<"missed in y=2, x>1"<<endl; 
	  // cout<<"non-matching events"<<endl;
	    int found188=0;
	    for(int x=0;x<maxnumber;x++){//want to find if there's a strip with 188
	      if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
		if((maxesarrayf[x]<197)&&(maxesarrayf[x]>178)) found188=1;//5% within 188
		hEnergyDeposit->Fill(maxesarrayf[x]);//again, just will with all the leftover strips
		hEnergyDepositGeDSSDx[maxesarraychf[x]-1]->Fill(maxesarrayf[x]);
		hEnergyDepositx->Fill(maxesarrayf[x]);
	      }
	      if((ymatch[x]==0)&&(x<2)){
		if((maxesarrayb[x]<197)&&(maxesarrayb[x]>178)) found188=1;//5% within 188
		hEnergyDepositGeDSSDy[maxesarraychb[x]-1]->Fill(maxesarrayb[x]);
		hEnergyDeposity->Fill(maxesarrayb[x]);
	      }
	    }
	    if(found188==1){
	      // printout=1;
	      // cout<<" "<<endl;
	      for(int x=0;x<maxnumber;x++){
		if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
		  //  hEnergyDeposit->Fill(maxesarrayf[x]);
		  //hEnergyDepositGeDSSDx[maxesarraychf[x]-1]->Fill(maxesarrayf[x]);
		  // cout<<"x "<<x<<" "<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
		}
		if((ymatch[x]==0)&&(x<2)){
		  //  cout<<"y "<<x<<" "<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
		  // hEnergyDepositGeDSSDy[maxesarraychb[x]-1]->Fill(maxesarrayb[x]);
		}
	      }
	    }else{
	      //  cout<<" "<<endl;
	      for(int x=0;x<maxnumber;x++){
		if((ymatch[x]==0)&&(x<2)){
		  hGeDSSD->Fill(maxesarrayb[x]);
		  //  printout=1;
		  // cout<<"y "<<x<<" "<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
		}
		if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
		  // printout=1;
		  hnotelectrony->Fill(maxesarrayf[x]);
		  //  cout<<"x "<<x<<" "<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
		}
	      }
	    }
	    //  cout<<"matching events"<<endl;
	    // for(int x=0;x<maxnumber;x++){
	    // if((ymatch[x]==1)&&(x<2)){
	    //  cout<<"y"<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	    // }
	    // if((xmatch[x]==1)&&(maxesarrayf[x]>0)){
	    // cout<<"x"<<maxesarrayf[x]<<" "<< maxesarraychf[x]<<endl;
	    // }
	    // }
      }else if((countf>2)&&(countb>2)){//>2:>2
	// }else{
	//start with 1:1 that don't have neighbors to get them out of the way
	for(int y=0;y<maxnumber;y++){
	  for(int x=0;x<maxnumber;x++){
	    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
	      int neighborf=0;
	      int neighborb=0;
	      for(int c=0; c<maxnumber;c++){
		if(maxesarrayb[c]>0){
		  if(abs(maxesarraychb[c]-maxesarraychb[y])==1) neighborb=1;
		}
		if(maxesarrayf[c]>0){
		  if(abs(maxesarraychf[c]-maxesarraychf[x])==1) neighborf=1;
		}

	      }
	      if((neighborb==0)&&(neighborf==0)){
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		//	cout<<"here"<<endl;
		ymatch[y]=1;
		xmatch[x]=1;
	      }
	    }
	  }
	}
     	for(int y=0;y<maxnumber;y++){
	  if(ymatch[y]==0){
	    for(int x=0;x<maxnumber;x++){
	      if((y<maxnumber-1)&&(x<maxnumber-1)){
		if((xmatch[x]==0)&&(xmatch[x+1]==0)&&(ymatch[y+1]==0)){
		  // if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)&&(maxesarrayb[y+1]>0)&&(maxesarrayb[y+1]>0))
		  if((abs((maxesarrayf[x]+maxesarrayf[x+1])-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]+maxesarrayf[x+1]))<percent){
		    //	if(((maxesarrayf[x]/maxesarrayb[y])<(1-percent))||((maxesarrayf[x]/maxesarrayb[y])>(1+percent))){
		    // if(((maxesarrayf[x+1]/maxesarrayb[y+1])<(1-percent))||((maxesarrayf[x+1]/maxesarrayb[y+1])>(1+percent))){
		    //  if((abs(maxesarrayf[x+1]-maxesarrayb[y+1])/maxesarrayb[y+1])<percent) cout<<"equal lower maxima "<<maxesarrayf[x+1]<<" "<<maxesarrayb[y+1]<<" "<<maxesarrayf[x]<<" "<<maxesarrayb[y] <<endl;
		      if(maxesarrayf[x]>maxesarrayb[y]){//start with only looking at one case
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+1];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			hEnergyDepositTest->Fill(maxesarrayb[y+1]);
			hEnergyDepositTest->Fill(maxesarrayf[x+1]);
			hEnergyDepositTest->Fill(maxesarrayb[y]-maxesarrayf[x+1]);
			/* totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			   totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[x+1];
			   totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayf[x]-maxesarrayb[y+1];*/
		      }else{
			/*  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+1];*/
			totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+1];
			totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			hEnergyDepositTest->Fill(maxesarrayf[x+1]);
			hEnergyDepositTest->Fill(maxesarrayf[x]-maxesarrayb[y+1]);
			hEnergyDepositTest->Fill(maxesarrayb[y+1]);
		      }
		    ymatch[y]=1;
		    ymatch[y+1]=1;
		    xmatch[x]=1;
		    xmatch[x+1]=1;
		    //  }
			//	}
			
			/*  }else if(((maxesarrayf[1]/maxesarrayb[1])>(1-percent))&&((maxesarrayf[1]/maxesarrayb[1])<(1+percent))){//if the 0's aren't outside of 1, and the 1's are also 1
			    totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
			    totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayb[1];
			    ymatch[0]=1;
			    ymatch[1]=1;
			    xmatch[0]=1;
			    xmatch[1]=1;
			    }
			    }*/
			}
		    }//end match x,y,and their +1's
		  }//end to make sure we're not going to go over the index
		  //if not, then do 1:2 for each of the spots on the front
		  if(x<maxnumber-2){
		    if((xmatch[x]==0)&&(xmatch[x+1]==0)&&(xmatch[x+2]==0)){
		      if((maxesarrayf[x+1]>0)&&(maxesarrayf[x+2]>0)){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  ymatch[y]=1;
			  xmatch[x+1]=1;
			  xmatch[x]=1;
			  xmatch[x+2]=1;
			}
		      }
		    }
		    if((xmatch[x]==0)&&(xmatch[x+1]==0)){
		      if(maxesarrayf[x+1]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  hEnergyDepositAlgorithmTest->Fill(maxesarrayf[x]);
			  hEnergyDepositAlgorithmTest->Fill(maxesarrayf[x+1]);
			  ymatch[y]=1;
			  xmatch[x+1]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		    if((xmatch[x]==0)&&(xmatch[x+2]==0)){//0+2
		      if(maxesarrayf[x+2]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
			  ymatch[y]=1;
			  xmatch[x+2]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		  }//end less than number-2
		  if(x<maxnumber-3){
		    /* if((xmatch[x]==0)&&(xmatch[x+1]==0)&&(xmatch[x+3]==0)){//didn't add in any more counts.
		      if((maxesarrayf[x+1]>0)&&(maxesarrayf[x+3]>0)){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+3]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  hEnergyDepositTest->Fill(maxesarrayf[x]);
			  hEnergyDepositTest->Fill(maxesarrayf[x+3]);
			  ymatch[y]=1;
			  xmatch[x+1]=1;
			  xmatch[x]=1;
			  xmatch[x+3]=1;
			}
		      }
		    }*/

		    if((xmatch[x]==0)&&(xmatch[x+3]==0)){
		      if(maxesarrayf[x+3]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+3]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  ymatch[y]=1;
			  xmatch[x+3]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		  }//end less than number -3
		  //do the same for the y sums
		  if(y<maxnumber-2){
		    if((ymatch[y]==0)&&(ymatch[y+1]==0)&&(ymatch[y+2]==0)){
		      if((maxesarrayb[y+1]>0)&&(maxesarrayb[y+2]>0)){
			if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]+maxesarrayb[y+2]))/(maxesarrayf[x]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  ymatch[y]=1;
			  ymatch[y+1]=1;
			  xmatch[x]=1;
			  ymatch[y+2]=1;
			}
		      }
		    }
		    if((ymatch[y]==0)&&(ymatch[y+1]==0)){//this will make it not re-match if if already did the one before
		      if(maxesarrayb[y+1]>0){
			if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  hEnergyDepositAlgorithmTest->Fill(maxesarrayb[y]);
			  hEnergyDepositAlgorithmTest->Fill(maxesarrayb[y+1]);
			  ymatch[y]=1;
			  ymatch[y+1]=1;
			  xmatch[0]=1;
			}
		      }
		    }
		    if((ymatch[y]==0)&&(ymatch[y+2]==0)){//0+2
		      if(maxesarrayb[y+2]>0){
			if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+2]))/(maxesarrayf[x]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
			  ymatch[y]=1;
			  ymatch[y+2]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		  }//end less than number-2
		  if(y<maxnumber-3){
		    if((ymatch[y]==0)&&(ymatch[y+3]==0)){
		      if(maxesarrayb[y+3]>0){
			if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+3]))/(maxesarrayf[x]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
			  //hEnergyDepositTest->Fill(maxesarrayb[y]);
			  // hEnergyDepositTest->Fill(maxesarrayb[y+3]);
			  ymatch[y]=1;
			  ymatch[y+3]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		  }//end less than number -3

		  //finally, look of 1:1 matches
		  if((ymatch[y]==0)&&(xmatch[x]==0)){//if this y still isn't matched, then try to match it to just the x
		    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      hEnergyDepositAlgorithmTest->Fill(maxesarrayb[y]);
		      ymatch[y]=1;
		      xmatch[x]=1;
		    }
		  }
		}//end x loop
	      }
	}//end y loop
	//	cout<<"missed in y>2, x>2"<<endl;   
	//	cout<<"non-matching maxima"<<endl;
	int found188=0;
	for(int x=0;x<maxnumber;x++){//want to find if there's a strip with 188
	  if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
	    if((maxesarrayf[x]<197)&&(maxesarrayf[x]>178)) found188=1;//5% within 188
	    hEnergyDeposit->Fill(maxesarrayf[x]);//filling with all leftover strips
	    hEnergyDepositGeDSSDx[maxesarraychf[x]-1]->Fill(maxesarrayf[x]);
	    hEnergyDepositx->Fill(maxesarrayf[x]);
	  }
	  if((ymatch[x]==0)&&(maxesarrayb[x]>0)){
	    if((maxesarrayb[x]<197)&&(maxesarrayb[x]>178)) found188=1;//5% within 188
	    hEnergyDepositGeDSSDy[maxesarraychb[x]-1]->Fill(maxesarrayb[x]);
	    hEnergyDeposity->Fill(maxesarrayb[x]);
	  }
	}
	if(found188==1){
	  //  printout=1;
	  //  cout<<" "<<endl;
	  for(int x=0;x<maxnumber;x++){
	    if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
	      //    hEnergyDeposit->Fill(maxesarrayf[x]);
	      //  hEnergyDepositGeDSSDx[maxesarraychf[x]-1]->Fill(maxesarrayf[x]);
	      //  cout<<"x "<<x<<" "<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
	     }
	    if((ymatch[x]==0)&&(maxesarrayb[x]>0)){
	      //cout<<"y "<<x<<" "<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	      // hEnergyDepositGeDSSDy[maxesarraychb[x]-1]->Fill(maxesarrayb[x]);
	    }
	   }
	}else{
	  //  cout<<" "<<endl;
	  for(int x=0;x<maxnumber;x++){
	    if((ymatch[x]==0)&&(maxesarrayb[x]>0)){
	      ///  printout=1;
	      hGeDSSD->Fill(maxesarrayb[x]); 
	      //  cout<<"y "<<x<<" "<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	     }
	    if((xmatch[x]==0)&&(maxesarrayf[x]>0)){
	      //  printout=1;
	      hnotelectrony->Fill(maxesarrayf[x]);
	      // cout<<"x "<<x<<" "<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
	    }
	   }
	}
	/*	cout<<"matching maxima"<<endl;
	for(int x=0;x<maxnumber;x++){
	  if((ymatch[x]==1)&&(maxesarrayb[x])){
	    cout<<"y"<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	  }
	  if((xmatch[x]==1)&&(maxesarrayf[x]>0)){
	    cout<<"x"<<maxesarrayf[x]<< " "<<maxesarraychf[x]<<endl;
	  }
	  }*/
      }//end multiplicity else if
      
    }//end testing!=1
#############################################################################################################################################
V4
if((countf==1)&&(countb==1)){//start with mult one both way events-we know that the x and y must go together
      mult1bothtotal=1;
      if(gamma189found==1) mult1both189=1;
      if((abs(maxesarrayf[0]-maxesarrayb[0])/maxesarrayf[0])<percent){
	totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
	if(maxesarrayb[0]>189 && maxesarrayb[0]<190) mult1bothfound189=1;
	hEnergyDepositAlgorithmTest->Fill(maxesarrayb[0]);
	hEnergyDepositmult1both->Fill(maxesarrayb[0]);
	hPercentMatch->Fill(abs(maxesarrayf[0]-maxesarrayb[0])/maxesarrayf[0]);
	maxesarrayb[0]=maxesarrayf[0]=0;
	maxesarraychb[0]=maxesarraychf[0]=20;
	mult1both=1;
	mult1bothnoleft=1;
      }
      // cout<<maxb<<" front"<<maxf<<endl;
      //   cout<<"mult one both sides"<<endl;
    }else if((countf==1)&&(countb>1)){//1:>1
      mult1fronttotal=1;
      if(gamma189found==1) mult1front189=1;
      if((abs(maxesarrayb[0]+maxesarrayb[1]+maxesarrayb[2]+maxesarrayb[3]+maxesarrayb[4]-maxesarrayf[0])/maxesarrayf[0])<percent){
	double ysum=0;
	for(int y=0;y<maxnumber;y++){
	  ysum+=maxesarrayb[y];
	  totaledepxy[maxesarraychf[0]][maxesarraychb[y]]=maxesarrayb[y];
	  hEnergyDepositmult1front->Fill(maxesarrayb[y]);
	  if(maxesarrayb[y]>189 && maxesarrayb[y]<190) mult1frontfound189=1;
	  hEnergyDepositAlgorithmTest->Fill(maxesarrayb[y]);
	  maxesarrayb[y]=0;
	  maxesarraychb[y]=20;
	}
	hPercentMatch->Fill(abs(maxesarrayf[0]-ysum)/ysum);
	maxesarrayf[0]=0;
	maxesarraychf[0]=20;
	mult1front=1;
	mult1frontnoleft=1;
      }
    }else if((countb==1)&&(countf>1)){//>1:1
      mult1backtotal=1;
      if(gamma189found==1) mult1back189=1;
      if((abs(maxesarrayf[0]+maxesarrayf[1]+maxesarrayf[2]+maxesarrayf[3]+maxesarrayf[4]-maxesarrayb[0])/maxesarrayb[0])<percent){
	double xsum=0;
	for(int x=0;x<maxnumber;x++){
	  xsum+=maxesarrayf[x];
	  totaledepxy[maxesarraychf[x]][maxesarraychb[0]]=maxesarrayf[x];
	  hEnergyDepositmult1back->Fill(maxesarrayf[x]);
	  if(maxesarrayf[x]>189 && maxesarrayf[x]<190) mult1backfound189=1;
	  hEnergyDepositAlgorithmTest->Fill(maxesarrayf[x]);
	  maxesarrayf[x]=0;
	  maxesarraychf[x]=20;
	}
	hPercentMatch->Fill(abs(maxesarrayb[0]-xsum)/xsum);
	maxesarrayb[0]=0;
	maxesarraychb[0]=20;
	mult1back=1;
	mult1backnoleft=1;
      }
    }else if((countf==2)&&(countb==2)){//it can only be 2 1:1's or 2 by 2's
      mult2bothtotal=1;
      if(gamma189found==1) mult2both189=1;
      if((abs((maxesarrayf[0]+maxesarrayf[1])-(maxesarrayb[0]+maxesarrayb[1]))/(maxesarrayf[0]+maxesarrayf[1]))<percent){
	mult2both=1;
	mult2bothnoleft=1;
	if((maxesarrayf[0]>0)&&(maxesarrayb[0]>0)&&(maxesarrayf[1]>0)&&(maxesarrayb[1]>0)){
	  //  if(((maxesarrayf[0]/maxesarrayb[0])<(1-percent))||((maxesarrayf[0]/maxesarrayb[0])>(1+percent))){
	  //	 if(((maxesarrayf[1]/maxesarrayb[1])<(1-percent))||((maxesarrayf[1]/maxesarrayb[1])>(1+percent))){
	  if(((abs(maxesarrayf[1]-maxesarrayb[1])/maxesarrayb[1])<percent)&&((abs(maxesarrayf[0]-maxesarrayb[0])/maxesarrayb[0])<percent)){//check that they just shouldn't be two 1:1 matches
	    hPercentMatch->Fill(abs(maxesarrayf[1]-maxesarrayb[1])/maxesarrayb[1]);
	    hPercentMatch->Fill(abs(maxesarrayf[0]-maxesarrayb[0])/maxesarrayb[0]);
	    totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
	    totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayf[1];
	  }else{
	    hPercentMatch->Fill(abs((maxesarrayf[0]+maxesarrayf[1])-(maxesarrayb[0]+maxesarrayb[1]))/(maxesarrayf[0]+maxesarrayf[1]));
	    // cout<<"2 both sides f0 ";//<<maxesarrayf[0]<<" b0 "<<maxesarrayb[0]<<" f1 "<<maxesarrayf[1]<<" b1 "<<maxesarrayb[1]<<endl;
	    // printout=1;
	    if(maxesarrayf[0]>maxesarrayb[0]){
	      if(((maxesarrayb[0]-maxesarrayf[1])>maxesarrayf[1])&&((maxesarrayb[0]-maxesarrayf[1])>maxesarrayb[1])){//trying to  make sure it's placing the maximum at the intersection of the highest energy strips
	      // if(((maxesarrayb[0])>maxesarrayf[1])&&((maxesarrayb[0])>(maxesarrayf[0]-maxesarrayb[0]))){ //testing if I swap the order of A and B which gets more correct
		twobytwoA++;
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];
		totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		//  cout<<maxesarrayb[0]-maxesarrayf[1]<<" "<< maxesarraychf[0]<<" "<<maxesarraychb[0]<<" "<<maxesarrayf[1]<<" "<< maxesarraychf[1]<<" "<<maxesarraychb[0]<<" "<<maxesarrayb[1]<<" "<< maxesarraychf[0]<<" "<<maxesarraychb[1]<<endl;
		if((abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]-totaledepxy[maxesarraychf[0]][maxesarraychb[0]])<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]-totaledepxy[maxesarraychf[1]][maxesarraychb[0]])<percent)&&(abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]-totaledepxy[maxesarraychf[0]][maxesarraychb[1]])<percent)) twobytwoAcorrect++;
		hEnergyDepositTest->Fill(maxesarrayb[1]);
		hEnergyDepositTest->Fill(maxesarrayf[1]);
		hEnergyDepositTest->Fill(maxesarrayb[0]-maxesarrayf[1]);
	    }else{//if the other way doesn't put the maximum in the right place, maybe version B might
		twobytwoB++;
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0];
		totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayf[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayf[0]-maxesarrayb[0];
		if((abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]-totaledepxy[maxesarraychf[0]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[1]]-totaledepxy[maxesarraychf[1]][maxesarraychb[1]])/totaledepxy2[maxesarraychf[1]][maxesarraychb[1]]<percent)&&(abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]-totaledepxy[maxesarraychf[0]][maxesarraychb[1]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]<percent)) twobytwoBcorrect++;
	      
		
	    }
	    }else{
	      if(((maxesarrayf[0]-maxesarrayb[1])>maxesarrayf[1])&&((maxesarrayf[0]-maxesarrayb[1])>maxesarrayb[1])){//trying to  make sure it's placing the maximum at the intersection of the highest energy strips
	      //  if(((maxesarrayf[0])>(maxesarrayb[0]-maxesarrayf[0]))&&((maxesarrayf[0]-maxesarrayb[1])>maxesarrayb[1])){
		twobytwoA++;
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0]-maxesarrayb[1];
		totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		hEnergyDepositTest->Fill(maxesarrayf[1]);
		hEnergyDepositTest->Fill(maxesarrayf[0]-maxesarrayb[1]);
		hEnergyDepositTest->Fill(maxesarrayb[1]);
		if((abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]-totaledepxy[maxesarraychf[0]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]-totaledepxy[maxesarraychf[1]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]-totaledepxy[maxesarraychf[0]][maxesarraychb[1]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]<percent)) twobytwoAcorrect++;	
	    }else{
		// cout<<maxesarrayf[0]-maxesarrayb[1]<<" "<< maxesarraychf[0]<<" "<<maxesarraychb[0]<<" "<<maxesarrayf[1]<<" "<< maxesarraychf[1]<<" "<<maxesarraychb[0]<<" "<<maxesarrayb[1]<<" "<< maxesarraychf[0]<<" "<<maxesarraychb[1]<<endl;
		twobytwoB++;
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0];
		totaledepxy[maxesarraychf[1]][maxesarraychb[1]]=maxesarrayb[1];
		totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[0];
		if((abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]-totaledepxy[maxesarraychf[0]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[1]]-totaledepxy[maxesarraychf[1]][maxesarraychb[1]])/totaledepxy2[maxesarraychf[1]][maxesarraychb[1]]<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]-totaledepxy[maxesarraychf[1]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]<percent)) twobytwoBcorrect++;
		
	      }
	    }
	  }//end check if they actually match 1:1 for both
	  maxesarrayb[0]=maxesarrayf[0]=maxesarrayb[1]=maxesarrayf[1]=0;
	  maxesarraychb[0]=maxesarraychf[0]=maxesarraychf[1]=maxesarraychb[1]=0;
	}//end matches
      }
      for(int x=1;x<17;x++){
	for(int y=1;y<17;y++){
	  if(totaledepxy[x][y]>189 && totaledepxy[x][y]<190) mult2bothfound189=1;
	  if(totaledepxy[x][y]>0) hEnergyDepositmult2both->Fill(totaledepxy[x][y]);
	  }
      }
      
     }else if((countf==2)&&(countb>2)){//2:>1
      printout=1;
      mult2fronttotal=1;
      if(gamma189found==1) mult2front189=1;
      //start with 1:1 that don't have neighbors to get them out of the way
      for(int x=0;x<2;x++){
	for(int y=0;y<maxnumber;y++){
	  if((maxesarrayb[y]>0)&&(maxesarrayf[x]>0)){
	    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
	      int neighborf=0;
	      int neighborb=0;
	      for(int c=0; c<maxnumber;c++){
		if(maxesarrayb[c]>0){
		  if(abs(maxesarraychb[c]-maxesarraychb[y])==1) neighborb=1;
		}
		if(maxesarrayf[c]>0){
		  if(abs(maxesarraychf[c]-maxesarraychf[x])==1) neighborf=1;
		}
		
	      }
	      if((neighborb==0)&&(neighborf==0)){
		mult2front=1;
		hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]));
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		maxesarraychf[x]=maxesarraychb[y]=20;
		maxesarrayf[x]=maxesarrayb[y]=0;
	      }
	    }
	  }//end >0
	}
      }
     
	  //if not, then do 1:2 for each of the spots on the front
      for(int x=0;x<2;x++){
	if(maxesarrayf[x]>0){
	  for(int y=0;y<maxnumber;y++){
	    if(y<maxnumber-2){//if i'm just doing y, y+1, y+2, no need for max-3-0+1+2
	      /*  if((maxesarrayb[y]>0)&&(maxesarrayb[y+1]>0)&&(maxesarrayb[y+2]>0)){
		if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]+maxesarrayb[y+2]))/(maxesarrayf[x]))<percent){
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		  maxesarrayb[y]=maxesarrayb[y+1]=maxesarrayb[y+2]=maxesarrayf[x]=0;
		  maxesarraychf[x]=maxesarraychb[y]=maxesarraychb[y+1]=maxesarraychb[y+2]=20;
		}
		}*/
	      
	      if((maxesarrayb[y]>0)&&(maxesarrayb[y+1]>0)){//this will make it not re-match if if already did the one before-0+1
		if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]))<percent){
		  mult2front=1;
		  hPercentMatch->Fill(abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]));
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		  maxesarraychf[x]=maxesarraychb[y]=maxesarraychb[y+1]=20;
		  maxesarrayf[x]=maxesarrayb[y]=maxesarrayb[y+1]=0;
		}
	      }
	      if((maxesarrayb[y]>0)&&(maxesarrayb[y+2]>0)){//0+2
		if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+2]))/(maxesarrayf[x]))<percent){
		  mult2front=1;
		  hPercentMatch->Fill(abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+2]))/(maxesarrayf[x]));
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		  maxesarrayf[x]=maxesarrayb[y]=maxesarrayb[y+2]=0;
		  maxesarraychf[x]=maxesarraychb[y]=maxesarraychb[y+2]=20;
		  
		}
	      }
	    }//end less than number-2

	  }//end y loop
	}//end x>0
	}//end x loop
	    /*	if(y<maxnumber-3){//this didn't actually seem to add anymore counts
		if((ymatch[y]==0)&&(ymatch[y+3]==0)){
		if(maxesarrayb[y+3]>0){
		if((abs(maxesarrayf[x]-(maxesarrayb[y]+maxesarrayb[y+3]))/(maxesarrayf[x]))<percent){
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		totaledepxy[maxesarraychf[x]][maxesarraychb[y+3]]=maxesarrayb[y+3];
		hEnergyDepositTest->Fill(maxesarrayb[y]);
		hEnergyDepositTest->Fill(maxesarrayb[y+3]);
		ymatch[y]=1;
		ymatch[y+3]=1;
		xmatch[x]=1;
		}
		}
		}
		}//end less than number -3*/
	    //trying to match the 2 on one side to 3 on the other
      for(int x=0;x<2;x++){
	for(int y=0;y<maxnumber;y++){
	    if((maxesarrayb[0]>0)&&(maxesarrayb[1]>0)&&(maxesarrayb[2]>0)&&(maxesarrayf[0]>0)&&(maxesarrayf[1]>0)){//if this y still isn't matched, then try to match it to just the x
	      if((abs((maxesarrayf[0]+maxesarrayf[1])-(maxesarrayb[0]+maxesarrayb[1]+maxesarrayb[2]))/(maxesarrayf[0]+maxesarrayf[1]))<percent){
		twobythree++;
		totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayb[0]-maxesarrayf[1];
		totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		totaledepxy[maxesarraychf[0]][maxesarraychb[2]]=maxesarrayb[2];
		if((abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]-totaledepxy[maxesarraychf[0]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]-totaledepxy[maxesarraychf[1]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]-totaledepxy[maxesarraychf[0]][maxesarraychb[1]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]<percent)&&(abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[2]]-totaledepxy[maxesarraychf[0]][maxesarraychb[2]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[2]]<percent)){
		  twobythreecorrect++;
		}else{
		  // compare=1;
		}
		maxesarrayb[0]=maxesarrayf[0]=maxesarrayb[1]=maxesarrayf[1]=maxesarrayb[2]=0;
		maxesarraychb[0]=maxesarraychf[0]=maxesarraychf[1]=maxesarraychb[1]=maxesarraychb[2]=20;
	      }
	    }
	      //finally, look of 1:1 matches
	    if((maxesarrayb[y]>0)&&(maxesarrayf[x]>0)){//if this y still isn't matched, then try to match it to just the x
	      if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		mult2front=1;
		hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]));
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		maxesarraychf[x]=maxesarraychb[y]=20;
		maxesarrayf[x]=maxesarrayb[y]=0;
		maxesarrayb[0]=maxesarrayf[0]=maxesarrayb[1]=maxesarrayf[1]=maxesarrayb[2]=0;
		maxesarraychb[0]=maxesarraychf[0]=maxesarraychf[1]=maxesarraychb[1]=maxesarraychb[2]=0;
	      }
	    }

	}//end y loop
      }//end x loop
      // }//end for the else after the 2:2
      //  cout<<"missed in x=2, y>1"<<endl; 
      //  cout<<"non-matching events"<<endl;
     	//  cout<<"matching events"<<endl;
	 // for(int x=0;x<maxnumber;x++){
	  //  if((xmatch[x]==1)&&(x<2)){
	       //     cout<<maxesarrayf[x]<< " x"<<x<<" "<<maxesarraychf[x]<<endl;
	    //   cout<<"x"<<maxesarrayf[x]<<" "<<maxesarraychf[x]<<endl;
	    // }
	    // if((ymatch[x]==1)&&(maxesarrayb[x]>0)){
	       //   cout<<maxesarrayb[x]<< " y"<<x<<" "<<maxesarraychb[x]<<endl;
	      // cout<<"y"<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	    // }
	    // }
      int left=0;
      for(int z =0;z<5;z++){
	if(maxesarrayb[z]>0) left=1;
	if(maxesarrayf[z]>0) left=1;
      }
      if(left==0) mult2frontnoleft=1;
      for(int x=1;x<17;x++){
	for(int y=1;y<17;y++){
	  if(totaledepxy[x][y]>189 && totaledepxy[x][y]<190) mult2frontfound189=1;
	  if(totaledepxy[x][y]>0) hEnergyDepositmult2front->Fill(totaledepxy[x][y]);
	  }
      }
    }else if((countb==2)&&(countf>2)){//>1:2
      mult2backtotal=1;
      if(gamma189found==1) mult2back189=1;
	//start with 1:1 that don't have neighbors to get them out of the way
      for(int y=0;y<2;y++){
	for(int x=0;x<maxnumber;x++){
	  if((maxesarrayb[y]>0)&&(maxesarrayf[x]>0)){
	    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
	      int neighborf=0;
	      int neighborb=0;
	      for(int c=0; c<maxnumber;c++){
		if(maxesarrayb[c]>0){
		  if(abs(maxesarraychb[c]-maxesarraychb[y])==1) neighborb=1;
		}
		if(maxesarrayf[c]>0){
		  if(abs(maxesarraychf[c]-maxesarraychf[x])==1) neighborf=1;
		}
		
	      }
	      if((neighborb==0)&&(neighborf==0)){
		mult2back=1;
		hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]));
		totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		maxesarraychf[x]=maxesarraychb[y]=20;
		maxesarrayf[x]=maxesarrayb[y]=0;
	      }
	    }
	  }//end>0
	}
      }
      
	  //if not, then do 1:2 for each of the spots on the front
	  for(int y=0;y<2;y++){
	    if(maxesarrayb[y]>0){
	      for(int x=0;x<maxnumber;x++){
		if(x<maxnumber-2){
		  /* if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)&&(maxesarrayf[x+2]>0)){//0+1+2
		    if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      maxesarraychf[x]=maxesarraychb[y]=maxesarraychf[x+1]=maxesarraychf[x+2]=20;
		      maxesarrayf[x]=maxesarrayf[x+1]=maxesarrayf[x+2]=maxesarrayb[y]=0;
		    }
		    }*/
		  if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)){//0+1
		    if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]))/(maxesarrayb[y]))<percent){
		      mult2back=1;
		      hPercentMatch->Fill(abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]))/(maxesarrayb[y]));
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		      maxesarraychf[x]=maxesarraychb[y]=maxesarraychf[x+1]=20;
		      maxesarrayf[x]=maxesarrayf[x+1]=maxesarrayb[y]=0;
		    }
		  }
		  if((maxesarrayf[x]>0)&&(maxesarrayf[x+2]>0)){//0+2
		    if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
		      mult2back=1;
		      hPercentMatch->Fill(abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+2]))/(maxesarrayb[y]));
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		      maxesarraychf[x]=maxesarraychb[y]=maxesarraychf[x+2]=20;
		      maxesarrayf[x]=maxesarrayf[x+2]=maxesarrayb[y]=0;
		    }
		  }
		}//end less than number-2
	      }//end x loop
	    }
	  }//end y loop
		  /*if(x<maxnumber-3){//this didn't actually seem to add anymore counts
		    if((xmatch[x]==0)&&(xmatch[x+3]==0)){
		      if(maxesarrayf[x+3]>0){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+3]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  hEnergyDepositTest->Fill(maxesarrayf[x]);
			  hEnergyDepositTest->Fill(maxesarrayf[x+3]);
			  ymatch[y]=1;
			  xmatch[x+3]=1;
			  xmatch[x]=1;
			}
		      }
		    }
		    }//end less than number -3*/
	  for(int y=0;y<2;y++){
	    for(int x=0;x<maxnumber;x++){
		if((maxesarrayb[0]>0)&&(maxesarrayf[1]>0)&&(maxesarrayf[2]>0)&&(maxesarrayf[0]>0)&&(maxesarrayb[1]>0)){//if this y still isn't matched, then try to match it to just the x
		  if((abs((maxesarrayb[0]+maxesarrayb[1])-(maxesarrayf[0]+maxesarrayf[1]+maxesarrayf[2]))/(maxesarrayb[0]+maxesarrayb[1]))<percent){
		    twobythree++;
		    totaledepxy[maxesarraychf[0]][maxesarraychb[0]]=maxesarrayf[0]-maxesarrayb[1];
		    totaledepxy[maxesarraychf[1]][maxesarraychb[0]]=maxesarrayf[1];
		    totaledepxy[maxesarraychf[2]][maxesarraychb[0]]=maxesarrayf[2];
		    totaledepxy[maxesarraychf[0]][maxesarraychb[1]]=maxesarrayb[1];
		    if((abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]-totaledepxy[maxesarraychf[0]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]-totaledepxy[maxesarraychf[1]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[1]][maxesarraychb[0]]<percent)&&(abs(totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]-totaledepxy[maxesarraychf[0]][maxesarraychb[1]])/totaledepxy2[maxesarraychf[0]][maxesarraychb[1]]<percent)&&(abs(totaledepxy2[maxesarraychf[2]][maxesarraychb[0]]-totaledepxy[maxesarraychf[2]][maxesarraychb[0]])/totaledepxy2[maxesarraychf[2]][maxesarraychb[0]]<percent)){
		      twobythreecorrect++;
		    }else{
		      // compare=1;
		    }
		    maxesarrayb[0]=maxesarrayf[0]=maxesarrayb[1]=maxesarrayf[1]=maxesarrayf[2]=0;
		    maxesarraychb[0]=maxesarraychf[0]=maxesarraychf[1]=maxesarraychb[1]=maxesarraychf[2]=20;
		  }
		}
		//finally, look of 1:1 matches
		if((maxesarrayf[x]>0)&&(maxesarrayb[y]>0)){
		  if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		    mult2back=1;
		    hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]));
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		    maxesarrayf[x]=maxesarrayb[y]=0;
		    maxesarraychf[x]=maxesarraychb[y]=0;
		  }
		}	    
	      }//end x loop
	  }//end y loop
	  
	    // }//end for the else for the 2:2 above
	    // cout<<"missed in y=2, x>1"<<endl; 
	  // cout<<"non-matching events"<<endl;
	    //  cout<<"matching events"<<endl;
	    // for(int x=0;x<maxnumber;x++){
	    // if((ymatch[x]==1)&&(x<2)){
	    //  cout<<"y"<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	    // }
	    // if((xmatch[x]==1)&&(maxesarrayf[x]>0)){
	    // cout<<"x"<<maxesarrayf[x]<<" "<< maxesarraychf[x]<<endl;
	    // }
	    // }
	  int left=0;
	  for(int z =0;z<5;z++){
	    if(maxesarrayb[z]>0) left=1;
	    if(maxesarrayf[z]>0) left=1;
	  }
	  if(left==0) mult2backnoleft=1;
	  for(int x=1;x<17;x++){
	    for(int y=1;y<17;y++){
	      if(totaledepxy[x][y]>189 && totaledepxy[x][y]<190) mult2backfound189=1;
	      if(totaledepxy[x][y]>0) hEnergyDepositmult2back->Fill(totaledepxy[x][y]);
	    }
	  }
    }else if((countf>2)&&(countb>2)){//>2:>2
      multgreaterthan2total=1;
      if(gamma189found==1) multgreaterthan2189=1;
      // }else{
	//start with 1:1 that don't have neighbors to get them out of the way
	for(int y=0;y<maxnumber;y++){
	  for(int x=0;x<maxnumber;x++){
	    if((maxesarrayb[y]>0)&&(maxesarrayf[x]>0)){
	      if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		int neighborf=0;
		int neighborb=0;
		for(int c=0; c<maxnumber;c++){
		  if(maxesarrayb[c]>0){
		    if(abs(maxesarraychb[c]-maxesarraychb[y])==1) neighborb=1;
		  }
		  if(maxesarrayf[c]>0){
		    if(abs(maxesarraychf[c]-maxesarraychf[x])==1) neighborf=1;
		  }
		  
		}
		if((neighborb==0)&&(neighborf==0)){
		  multgreaterthan2=1;
		  hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]));
		  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		  //	cout<<"here"<<endl;
		  maxesarraychf[x]=maxesarraychb[y]=20;
		  maxesarrayf[x]=maxesarrayb[y]=0;
		}
	      }
	    }//end >0
	  }
	}
     	for(int y=0;y<maxnumber;y++){
	  if(maxesarrayb[y]>0){
	    for(int x=0;x<maxnumber;x++){
	      //if not, then do 1:2 for each of the spots on the front
	      if(x<maxnumber-2){
		/*if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)&&(maxesarrayf[x+2]>0)){
		  if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    maxesarraychf[x]=maxesarraychb[y]=maxesarraychf[x+1]=maxesarraychf[x+2]=20;
		    maxesarrayf[x]=maxesarrayb[y]=maxesarrayf[x+1]=maxesarrayf[x+2]=0;
		  }
		  }*/
		if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)){
		  if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]))/(maxesarrayb[y]))<percent){
		    multgreaterthan2=1;
		    hPercentMatch->Fill(abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]))/(maxesarrayb[y]));
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    hEnergyDepositAlgorithmTest->Fill(maxesarrayf[x]);
		    hEnergyDepositAlgorithmTest->Fill(maxesarrayf[x+1]);
		    maxesarraychf[x]=maxesarraychf[x+1]=maxesarraychb[y]=20;
		    maxesarrayf[x]=maxesarrayf[x+1]=maxesarrayb[y]=0;
		  }
		}
		if((maxesarrayf[x]>0)&&(maxesarrayf[x+2]>0)){//0+2
		  if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+2]))/(maxesarrayb[y]))<percent){
		    multgreaterthan2=1;
		    hPercentMatch->Fill(abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+2]))/(maxesarrayb[y]));
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+2]][maxesarraychb[y]]=maxesarrayf[x+2];
		    maxesarraychf[x]=maxesarraychf[x+2]=maxesarraychb[y]=20;
		    maxesarrayf[x]=maxesarrayf[x+2]=maxesarrayb[y]=0;
		  }
		}
	      }//end less than number-2
	      if(x<maxnumber-3){
		/* if((xmatch[x]==0)&&(xmatch[x+1]==0)&&(xmatch[x+3]==0)){//didn't add in any more counts.
		   if((maxesarrayf[x+1]>0)&&(maxesarrayf[x+3]>0)){
			if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+1]+maxesarrayf[x+3]))/(maxesarrayb[y]))<percent){
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
			  hEnergyDepositTest->Fill(maxesarrayf[x]);
			  hEnergyDepositTest->Fill(maxesarrayf[x+3]);
			  ymatch[y]=1;
			  xmatch[x+1]=1;
			  xmatch[x]=1;
			  xmatch[x+3]=1;
			}
		      }
		    }*/

		if((maxesarrayf[x]==0)&&(maxesarrayf[x+3]==0)){
		  if((abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+3]))/(maxesarrayb[y]))<percent){
		    multgreaterthan2=1;
		    hPercentMatch->Fill(abs(maxesarrayb[y]-(maxesarrayf[x]+maxesarrayf[x+3]))/(maxesarrayb[y]));
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		    totaledepxy[maxesarraychf[x+3]][maxesarraychb[y]]=maxesarrayf[x+3];
		    maxesarraychf[x]=maxesarraychf[x+3]=maxesarraychb[y]=20;
		    maxesarrayf[x]=maxesarrayf[x+3]=maxesarrayb[y]=0;
		  }
		}
	      }//end less than number -3
	      //do the same for the y sums-i've switched the variables so both compare in the same manner within the loops.
	      if(x<maxnumber-2){
		/*	if((maxesarrayb[x]>0)&&(maxesarrayb[x+1]>0)&&(maxesarrayb[x+2]>0)){
		  if((abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+1]+maxesarrayb[x+2]))/(maxesarrayf[y]))<percent){
		      totaledepxy[maxesarraychf[y]][maxesarraychb[x]]=maxesarrayb[x];
		      totaledepxy[maxesarraychf[y]][maxesarraychb[x+1]]=maxesarrayb[x+1];
		      totaledepxy[maxesarraychf[y]][maxesarraychb[x+2]]=maxesarrayb[x+2];
		      maxesarraychf[y]=maxesarraychb[x+1]=maxesarraychb[x]=maxesarraychb[x+2]=20;
		      maxesarrayf[y]=maxesarrayb[x+1]=maxesarrayb[x]=maxesarrayb[x+2]=0;
		  }
		  }*/
		if((maxesarrayb[x]>0)&&(maxesarrayb[x+1]>0)){//this will make it not re-match if if already did the one before
		  if((abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+1]))/(maxesarrayf[y]))<percent){
		    multgreaterthan2=1;
		    hPercentMatch->Fill(abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+1]))/(maxesarrayf[y]));
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x]]=maxesarrayb[x];
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x+1]]=maxesarrayb[x+1];
		    hEnergyDepositAlgorithmTest->Fill(maxesarrayb[x]);
		    hEnergyDepositAlgorithmTest->Fill(maxesarrayb[x+1]);
		    maxesarraychf[y]=maxesarraychb[x+1]=maxesarraychb[x]=20;
		    maxesarrayf[y]=maxesarrayb[x+1]=maxesarrayb[x]=0;
		  }
		}
		if((maxesarrayb[x]>0)&&(maxesarrayb[x+2]>0)){//0+2
		  if((abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+2]))/(maxesarrayf[y]))<percent){
		    multgreaterthan2=1;
		    hPercentMatch->Fill(abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+2]))/(maxesarrayf[y]));
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x]]=maxesarrayb[x];
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x+2]]=maxesarrayb[x+2];
		    maxesarraychf[y]=maxesarraychb[x+2]=maxesarraychb[x]=20;
		    maxesarrayf[y]=maxesarrayb[x+2]=maxesarrayb[x]=0;
		  }
		}
	      }//end less than number-2
	      if(x<maxnumber-3){
		if((maxesarrayb[x]>0)&&(maxesarrayb[x+3]>0)){
		  if((abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+3]))/(maxesarrayf[y]))<percent){
		    multgreaterthan2=1;
		    hPercentMatch->Fill(abs(maxesarrayf[y]-(maxesarrayb[x]+maxesarrayb[x+3]))/(maxesarrayf[y]));
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x]]=maxesarrayb[x];
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x+3]]=maxesarrayb[x+3];
		    maxesarraychf[y]=maxesarraychb[x+3]=maxesarraychb[x]=20;
		    maxesarrayf[y]=maxesarrayb[x+3]=maxesarrayb[x]=0;
		    //hEnergyDepositTest->Fill(maxesarrayb[x]);
		    // hEnergyDepositTest->Fill(maxesarrayb[x+3]);
		  }
		}
	      }//end less than number -3
	    }//end x loop
	  }
	}//end y loop
	for(int y=0;y<maxnumber;y++){
	  for(int x=0;x<maxnumber;x++){
	    if((y<maxnumber-1)&&(x<maxnumber-1)){
	      if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)&&(maxesarrayb[y+1]>0)){
		  // if((maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)&&(maxesarrayb[y+1]>0)&&(maxesarrayb[y+1]>0))
		  if((abs((maxesarrayf[x]+maxesarrayf[x+1])-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]+maxesarrayf[x+1]))<percent){
		    multgreaterthan2=1;
		    //	if(((maxesarrayf[x]/maxesarrayb[y])<(1-percent))||((maxesarrayf[x]/maxesarrayb[y])>(1+percent))){
		    // if(((maxesarrayf[x+1]/maxesarrayb[y+1])<(1-percent))||((maxesarrayf[x+1]/maxesarrayb[y+1])>(1+percent))){
		    //  if((abs(maxesarrayf[x+1]-maxesarrayb[y+1])/maxesarrayb[y+1])<percent) cout<<"equal lower maxima "<<maxesarrayf[x+1]<<" "<<maxesarrayb[y+1]<<" "<<maxesarrayf[x]<<" "<<maxesarrayb[y] <<endl;
		    if(((abs(maxesarrayf[x+1]-maxesarrayb[y+1])/maxesarrayb[y+1])<percent)&&((abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayb[y])<percent)){//check that they just shouldn't be two 1:1 matches
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
		      totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		      hPercentMatch->Fill(abs(maxesarrayf[x+1]-maxesarrayb[y+1])/maxesarrayb[y+1]);
		      hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/maxesarrayb[y]);
		      hPercentMatch->Fill(abs((maxesarrayf[x]+maxesarrayf[x+1])-(maxesarrayb[y]+maxesarrayb[y+1]))/(maxesarrayf[x]+maxesarrayf[x+1]));
		    }else{
		      //  cout<<"greater than 2 both sides ";//<<maxesarraychf[x]<<" "<<maxesarrayf[x]<<" "<<maxesarraychb[y]<<" "<<maxesarrayb[y]<<" "<<maxesarraychf[x+1]<<" "<<maxesarrayf[x+1]<<" "<<maxesarraychb[y+1]<<" "<<maxesarrayb[y+1]<<endl;
		      // printout=1;
		      if(maxesarrayf[x]>maxesarrayb[y]){//start with only looking at one case
			if(((maxesarrayb[y]-maxesarrayf[x+1])>maxesarrayf[x+1])&&((maxesarrayb[y]-maxesarrayf[x+1])>maxesarrayb[y+1])){//trying to  make sure it's placing the maximum at the intersection of the highest energy strips
			//	if(((maxesarrayb[y])>maxesarrayf[x+1])&&((maxesarrayb[y])>(maxesarrayf[x]-maxesarrayb[y]))){
			  twobytwoA++;
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  //	cout<<maxesarrayb[y]-maxesarrayf[x+1]<<" "<< maxesarraychf[x]<<" "<<maxesarraychb[y]<<" "<<maxesarrayf[x+1]<<" "<< maxesarraychf[x+1]<<" "<<maxesarraychb[y]<<" "<<maxesarrayb[y+1]<<" "<< maxesarraychf[x]<<" "<<maxesarraychb[y+1]<<endl;
			  hEnergyDepositTest->Fill(maxesarrayb[y+1]);
			  hEnergyDepositTest->Fill(maxesarrayf[x+1]);
			  hEnergyDepositTest->Fill(maxesarrayb[y]-maxesarrayf[x+1]);
			  if((abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]<percent)) twobytwoAcorrect++;
			}else{
			  twobytwoB++;
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayf[x]-maxesarrayb[y];
			  if((abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y+1]]-totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]])/totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y+1]]<percent)&&(abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]<percent)) twobytwoBcorrect++;
			}
		      }else{
			if(((maxesarrayf[x]-maxesarrayb[y+1])>maxesarrayf[x+1])&&((maxesarrayf[x]-maxesarrayb[y+1])>maxesarrayb[y+1])){//trying to  make sure it's placing the maximum at the intersection of the highest energy strips
			  //  if(((maxesarrayf[x])>(maxesarrayb[y]-maxesarrayf[x]))&&((maxesarrayf[x])>maxesarrayb[y+1])){
			  twobytwoA++;
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x]-maxesarrayb[y+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  //	cout<<maxesarrayf[x]-maxesarrayb[y+1]<<" "<< maxesarraychf[x]<<" "<<maxesarraychb[y]<<" "<<maxesarrayf[x+1]<<" "<< maxesarraychf[x+1]<<" "<<maxesarraychb[y]<<" "<<maxesarrayb[y+1]<<" "<< maxesarraychf[x]<<" "<<maxesarraychb[y+1]<<endl;
			  hEnergyDepositTest->Fill(maxesarrayf[x+1]);
			  hEnergyDepositTest->Fill(maxesarrayf[x]-maxesarrayb[y+1]);
			  hEnergyDepositTest->Fill(maxesarrayb[y+1]);
			  if((abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]<percent)) twobytwoAcorrect++;
			}else{
			  twobytwoB++;
			  totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayf[x];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]]=maxesarrayb[y+1];
			  totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x];
			  if((abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y+1]]-totaledepxy[maxesarraychf[x+1]][maxesarraychb[y+1]])/totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y+1]]<percent)&&(abs(totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]<percent)) twobytwoBcorrect++;
			}
		      }
		    }//end checking for 1:1 instead
		    maxesarrayf[x]=maxesarrayf[x+1]=maxesarrayb[y]=maxesarrayb[y+1]=0;
		    maxesarraychf[x]=maxesarraychf[x+1]=maxesarraychb[y]=maxesarraychb[y+1]=20;
		  }
		}//end match x,y,and their +1's
	      }//end to make sure we're not going to go over the index
	      //looking for 2:3 matches
	      if((y<maxnumber-2)&&(x<maxnumber-1)){
		if((maxesarrayb[y]>0)&&(maxesarrayb[y+1]>0)&&(maxesarrayb[y+2]>0)&&(maxesarrayf[x]>0)&&(maxesarrayf[x+1]>0)){//if this y still isn't matched, then try to match it to just the x
		  if((abs((maxesarrayf[x]+maxesarrayf[x+1])-(maxesarrayb[y]+maxesarrayb[y+1]+maxesarrayb[y+2]))/(maxesarrayf[x]+maxesarrayf[x+1]))<percent){
		    twobythree++;
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y]-maxesarrayf[x+1];
		    totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]]=maxesarrayf[x+1];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]]=maxesarrayb[y+1];
		    totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]]=maxesarrayb[y+2];
		    if((abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]-totaledepxy[maxesarraychf[x+1]][maxesarraychb[y]])/totaledepxy2[maxesarraychf[x+1]][maxesarraychb[y]]<percent)&&(abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y+1]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y+1]]<percent)&&(abs(totaledepxy2[maxesarraychf[x]][maxesarraychb[y+2]]-totaledepxy[maxesarraychf[x]][maxesarraychb[y+2]])/totaledepxy2[maxesarraychf[x]][maxesarraychb[y+2]]<percent)){
		      twobythreecorrect++;
		    }else{
		      // compare=1;
		    }
		    maxesarrayb[y]=maxesarrayf[x]=maxesarrayb[y+1]=maxesarrayf[x+1]=maxesarrayb[y+2]=0;
		    maxesarraychb[y]=maxesarraychf[x]=maxesarraychf[x+1]=maxesarraychb[y+1]=maxesarraychb[y+2]=20;
		  }
		}
	      }//end checking indicies
	      if((y<maxnumber-2)&&(x<maxnumber-1)){
		if((maxesarrayb[x]>0)&&(maxesarrayf[y+1]>0)&&(maxesarrayf[y+2]>0)&&(maxesarrayf[y]>0)&&(maxesarrayb[x+1]>0)){//if this y still isn't matched, then try to match it to just the x
		  if((abs((maxesarrayb[x]+maxesarrayb[x+1])-(maxesarrayf[y]+maxesarrayf[y+1]+maxesarrayf[y+2]))/(maxesarrayb[x]+maxesarrayb[x+1]))<percent){
		    twobythree++;
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x]]=maxesarrayf[y]-maxesarrayb[x+1];
		    totaledepxy[maxesarraychf[y+1]][maxesarraychb[x]]=maxesarrayf[y+1];
		    totaledepxy[maxesarraychf[y+2]][maxesarraychb[x]]=maxesarrayf[y+2];
		    totaledepxy[maxesarraychf[y]][maxesarraychb[x+1]]=maxesarrayb[x+1];
		    if((abs(totaledepxy2[maxesarraychf[y]][maxesarraychb[x]]-totaledepxy[maxesarraychf[y]][maxesarraychb[x]])/totaledepxy2[maxesarraychf[y]][maxesarraychb[x]]<percent)&&(abs(totaledepxy2[maxesarraychf[y+1]][maxesarraychb[x]]-totaledepxy[maxesarraychf[y+1]][maxesarraychb[x]])/totaledepxy2[maxesarraychf[y+1]][maxesarraychb[x]]<percent)&&(abs(totaledepxy2[maxesarraychf[y]][maxesarraychb[x+1]]-totaledepxy[maxesarraychf[y]][maxesarraychb[x+1]])/totaledepxy2[maxesarraychf[y]][maxesarraychb[x+1]]<percent)&&(abs(totaledepxy2[maxesarraychf[y+2]][maxesarraychb[x]]-totaledepxy[maxesarraychf[y+2]][maxesarraychb[x]])/totaledepxy2[maxesarraychf[y+2]][maxesarraychb[x]]<percent)){
		      twobythreecorrect++;
		    }else{
		      // compare=1;
		    }
		    maxesarrayb[x]=maxesarrayf[y]=maxesarrayb[x+1]=maxesarrayf[y+1]=maxesarrayf[y+2]=0;
		    maxesarraychb[x]=maxesarraychf[y]=maxesarraychf[y+1]=maxesarraychb[x+1]=maxesarraychf[y+2]=20;
		  }
		}
	      }//end checking indicies
		  //finally, look of 1:1 matches
		  if((maxesarrayb[y]>0)&&(maxesarrayf[x]>0)){//if this y still isn't matched, then try to match it to just the x
		    if((abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]))<percent){
		      multgreaterthan2=1;
		      hPercentMatch->Fill(abs(maxesarrayf[x]-maxesarrayb[y])/(maxesarrayf[x]));
		      totaledepxy[maxesarraychf[x]][maxesarraychb[y]]=maxesarrayb[y];
		      hEnergyDepositAlgorithmTest->Fill(maxesarrayb[y]);
		      maxesarraychf[x]=maxesarraychb[y]=20;
		      maxesarrayf[x]=maxesarrayb[y]=0;
		    }
		  }
	  }//end x loop
	}//end y loop
	//	cout<<"missed in y>2, x>2"<<endl;   
	//	cout<<"non-matching maxima"<<endl;
	/*	cout<<"matching maxima"<<endl;
	for(int x=0;x<maxnumber;x++){
	  if((ymatch[x]==1)&&(maxesarrayb[x])){
	    cout<<"y"<<maxesarrayb[x]<<" "<<maxesarraychb[x]<<endl;
	  }
	  if((xmatch[x]==1)&&(maxesarrayf[x]>0)){
	    cout<<"x"<<maxesarrayf[x]<< " "<<maxesarraychf[x]<<endl;
	  }
	  }*/
	int left=0;
	  for(int z =0;z<5;z++){
	    if(maxesarrayb[z]>0) left=1;
	    if(maxesarrayf[z]>0) left=1;
	  }
	  if(left==0) multgreaterthan2noleft=1;
	  for(int x=1;x<17;x++){
	    for(int y=1;y<17;y++){
	      if(totaledepxy[x][y]>189 && totaledepxy[x][y]<190) multgreaterthan2found189=1;
	      if(totaledepxy[x][y]>0) hEnergyDepositmultgreaterthan2->Fill(totaledepxy[x][y]);
	    }
	  }
      }//end multiplicity else if
###################################################################################################################################
